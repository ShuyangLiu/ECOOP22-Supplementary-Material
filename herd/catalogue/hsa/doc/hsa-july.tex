\makeatletter
\@ifundefined{bwtrue}{\newif\ifbw\bwfalse}{}
\@ifundefined{acmtrue}{\newif\ifacm\acmtrue}{}
\makeatother
\makeatletter
\let\@period=\,
\makeatother
\documentclass[a4paper]{article}
\usepackage{xspace}
\usepackage{color}
\usepackage[leqno]{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{url}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{graphicx}
%\usepackage{rotating}
%\usepackage{adjustbox}
\usepackage{lscape}
\usepackage{subfig}
\usepackage{epsfig}
\usepackage{multicol}
\usepackage{float}
\usepackage[final]{fixme}
\newif\ifcomments
\commentsfalse
\usepackage{url}
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\small\sf}}{\def\UrlFont{\small\sf}}}
\makeatother
\urlstyle{leo}
\usepackage[normalem]{ulem}
\input{macros}
\input{macros2}

\renewcommand{\topfraction}{0.9}
\begin{document}
\title{Towards an HSA model in {\tt .cat}}
\author{Jade Alglave and Luc Maranget}
\maketitle
\let\prog\textsf

This note presents our progress on implementing an HSA model, based on our
reading of the
documentation (see \url{http://www.hsafoundation.com/html/HSA_Library.htm#SysArch/Topics/03_Memory/_chpStr_HSA_memory_consistency_model.htm})
and interactions with the HSA working group.

\input{motivation.tex}

\tableofcontents

\pagebreak
\input{axiomatic.tex}
\input{semantics-bricks.tex}

\section{Bell file \label{sec:bell}}

We gather all the definitions over events, their tags, and the concurrency
hierarchy in a {\tt bell} file, which we give below.

\verbatiminput{hsa.bell}

\pagebreak

\section{Axioms}

We now go through the constraint specification part of our model. 

\subsection{Utilitarian definitions}

To make this document as self-contained as we can, we start off with some
utilitarian definitions that we use later in the model. 

\subsubsection{\label{procedure}Checks and procedures}
A model text is a list of instructions.

Checks are special instructions that, depending on their outcome, will let the
execution of the model continue or on the contrary stop it.

For instance we can test that the two relations \coh{} and \po{} are consistent
with the instruction:
\begin{verbatim}
irreflexive coh;po as CohPoCons
\end{verbatim}

Here, execution will continue when \coh{} and~\po{} are consistent, \emph{i.e.}
when the sequence relation $\coh; \po$ is irreflexive.  Note that checks have
an optional name, introduced by the \texttt{as} keyword, e.g. for documentation
purposes.

In the case of the consistency check it may be interesting to abstract the
details of the check by defining a procedure:
\begin{verbatim}
procedure consistent(a,b) =
  irreflexive a;b
end
\end{verbatim}

A procedure is called by using the explicit ``\texttt{call}'' keyword.
As an example the consistency of \coh{} and~\po{} can be checked as follows:
\begin{verbatim}
call consistent(coh,po) as CohPoCons
\end{verbatim}

Procedures can of course call other procedures.
For instance we define equality by double inclusion as follows:
\begin{verbatim}
(* Relation a includes relation b, ie b(x,y) => a(x,y) *)
procedure includes(a,b) = empty b \ a end
procedure equals(a,b) =
  call includes(a,b)
  call includes(b,a)
end
\end{verbatim}
Notice how the set difference operator ``\verb+\+'' is used to express
inclusion: we have $b \subseteq a$ if and only if $b \setminus a$ is empty.

\subsubsection{\label{coh}Generating \coh}

The coherence relation can be generated by \prog{herd} from the $\coinit$
pre-defined relation. The relation $\coinit$ expresses some constraints on the
writes: it relates initial writes to all other writes and all non-final writes
to final writes, for each location~$L$.

%These constraints on writes are introduced by \prog{herd} initial machinery
%that enumerates all candidate executions, considering all possible
%final writes\footnote{As a matter of fact, we assume that each location
%holds a well defined value at the end of program execution, and we
%enumerate all such final values.} in turn.

In \prog{herd}, we can generate all orders on a certain set of events with the
\texttt{linearisations($S$,$R$)} primitive that takes two arguments: a set of
events~$S$ and a relation~$R$.  The primitive builds $R_S$, the restriction
of~$R$ to $S$ (written \texttt{$R$ \& ($S$ * $S$)} in the \cat{} language).  If
$R_S$ is acyclic, the call to {\tt linearisations} will return the set of all
total orders that extend $R_S$. Otherwise, \emph{i.e.} if $R_S$ has a cycle,
the primitive returns the empty set. 
%\fixme{jade@Luc: il nous faut des crobards ici}

Hence, assuming $S_L$ to be the set of all memory events to location~$L$,
one can generate the set of all possible $\cohl{L}$ by the call
\texttt{linearisations($S_L$,co0)}:
\begin{verbatim}
let makeCohL(s) = linearisations(s,co0)
\end{verbatim}

In fact, we want to generate the set of all possible $\coh$ relations,
\emph{i.e.} all the unions of all the possible $\cohl{L}$ orders for all
locations~$L$. To that end we use another \cat{} primitive:
\texttt{partition($S$)}, which takes a set of events as argument and
returns a set of set of events $T = \{S_1,\ldots,S_n\}$, where each
$S_i$ is the set of all events in $S$ that act on location $L_i$,
and, of course $S$ is the union $\bigcup_{i=1}^{i=n} S_i$.
%\fixme{jade@Luc: il nous faut des crobards ici}

To combining the effect of the \texttt{partition} and \texttt{linearisations}
primitives, we first define a \texttt{map} function that, given a set~$S=
\{e_1,\ldots,e_n\}$ and a function $f$, returns the set
$\{f(e_1),\ldots,f(e_n)\}$:
\begin{verbatim}
let map f  =
  let rec do_map es = match es with
  || {} -> {}
  || e ++ es -> f e ++ do_map es
  end in
  do_map
\end{verbatim}
%Notice that \texttt{map} is written in curried style.
%\vspace*{-2mm}
%\includegraphics[width=10cm]{map}

The code above uses some new \cat{} constructs: ``\texttt{++}'' is set addition
(in infix notation), ``\verb+{}+ is the empty set.

It also uses set pattern matching that permits recursion over sets,
by considering the empty and non-empty cases, in a manner similar
to list pattern matching.

Then, we generate the set of all possible \cohl{L} for all locations~$L$ as
follows:
\begin{verbatim}
let allCohL = map makeCohL (partitions(M))
\end{verbatim}
%\fixme{jade@Luc: il nous faut des crobards ici}

Now, \texttt{allCohL} is a set of set of relations, each element being the
set of all possible $\cohl{L}$ orders for a specific~$L$.  

We still need to generate all possible unions of the $\cohl{L}$ for
% all possible choices of those\fixme{jade@Luc: c'est qui those ici?} and 
all possible locations~$L$.  It can be done by another \cat{} function:
\texttt{cross}, which takes a set of sets $S = \{S_1, S_2, \ldots, S_n\}$ as
argument and returns all possible unions built by picking elements from each of
the $S_i$: 
%\fixme{jade@Luc: il nous faut des crobards ici}

$$
\left\{\, e_1 \cup e_2 \cup \cdots \cup e_n \mid
e_1 \in S_1, e_2 \in S_2, \ldots, e_n \in S_n \,\right\}
$$

We first define a classical \texttt{fold} function over sets:
given a set $S = \{ e_1, e_2, \ldots, e_n\}$, an initial value~$y_0$
and an associative function $f$~that takes a pair $(e,y)$ as argument,
\texttt{fold} computes:
$$
f (e_{i_1},f (e_{i_2}, \ldots, f(e_{i_n},y_0)))  
$$
where $i_1, i_2, \ldots, i_n$ defines a permutation
of the indices $1, 2, \ldots, n$.

\begin{verbatim}
let fold f =
  let rec fold_rec (es,y) = match es with
  || {} -> y
  || e ++ es -> fold_rec (es,f (e,y))
  end in
  fold_rec
\end{verbatim}
As an example, consider:
\begin{verbatim}
let flatten S = fold (fun (e,y) -> e | y) (S,{})
\end{verbatim}
The function~\verb+flatten+
takes a set of sets as argument and returns their union.
As another example, we could have defined \texttt{map} as follows:
\begin{verbatim}
let map f = fun S -> fold (fun (e,y) -> f S ++ y) (S,{})
\end{verbatim}

We now write \texttt{cross}:
\begin{verbatim}
let rec cross ess = match ess with
  || {} -> { 0 }
  || es ++ ess ->
      let yss = cross ess in
      fold
        (fun (e,r) -> map (fun ys -> e | ys) yss | r)
        (es,{})           
  end      
\end{verbatim}
Notice, in the code above, that we use the union operator ``\verb+|+'' and of
the empty relation ``\verb+0+''. 

Finally we generate all possible $\coh$ ``orders'' by:
\begin{verbatim}
let allCoh = cross allCohL
\end{verbatim}

\subsection{\label{coherence}Coherence}

For a given location~$L$, the coherence order $\cohl{L}$ is defined as a total
order on all loads and stores to location~$L$. The single Coherent Order $\coh$
is the union of all these orders for all locations.  In appendix~\ref{coh} we
describe how to generate the set of all possible $\coh$ orders in the \cat{}
language.  For now, let us assume a variable \texttt{allCoh} whose value is the
set of all possible \coh{} orders.

The instruction \texttt{with $v$ from $S$} will, for each~$e$ in $S$, execute
the rest of the model in an extended environment that binds $v$ to~$e$. For
\coh{}, we write: \verb+with coh from allCoh+. This means that we bind the
variable {\tt coh} to a \coh{} order picked in the set {\tt allCoh}. 

\subsubsection{Consistency of {\tt coh} and {\tt po}}

We can then  check the consistency of $\coh$ and~$\po$:
\begin{verbatim}
call consistent(coh,po) as CohPoCons
\end{verbatim}
See Section~\ref{procedure} for the definition of the consistency check as a
procedure.

%\includegraphics[width=08cm]{allcoh}

\subsubsection{Value of a load}

The ``value of a load'' check states that: ``\emph{a load [\ldots] will always
observe the most recent store in the coherent order of location~$L$}''.

Given a read of location $L$, we find ``the most recent store in the coherent
order of location $L$'' using the relation \texttt{mincohWR}. This relation
is implemented in the \cat{} language as follows:
\begin{verbatim}
let cohWR = coh & (W * R)
let cohWW = coh & (W * W)
let mincohWR = cohWR \ (cohWW; cohWR)
\end{verbatim}
where \verb+W+ is the set of all writes, \verb+R+ the set of all reads,
\verb+W*R+ is the set of write-read pairs (which can also be viewed as a
relation that relates any write to all reads), \verb+W*W+ the set of
write-write pairs, ``\verb+&+'' is intersection, ``\verb+*+'' is cartesian
product and ``\verb+\+'' is (set or relation) difference. To implement ``value
of a load'', we check that $\rf$ equals \texttt{mincohWR}:

\verb+call equals(rf,mincohWR) as LoadCons+

%\includegraphics[width=10cm]{value-of-a-load}
%\vspace*{-2mm}
 
See Section~\ref{procedure} for the definition of the procedure {\tt equals}.

\subsubsection{\label{rmw}Read-modify-writes}

A RMW operation corresponds to two events, a read and a write, which are
related by a pre-defined \texttt{rmw} relation.

We state the atomicity of RMW's as follows:
\begin{verbatim}
let cohRW = coh & (R * W)
empty rmw & (cohRW;cohWW) as RmwCons
\end{verbatim}

%\includegraphics[width=10cm]{rmwcons}

\subsection{Local and global dependence orders}

\subsubsection{Local dependence order}

The document defines the ``local dependence order'' $\ldo$ informally as the
union of data, address and control dependencies (Sec 3.8).

Our \prog{herd} tool provides pre-defined relations for the three kinds of
dependency relations:
Hence we write
\begin{verbatim}
let ldo = data | addr | ctrl
\end{verbatim}

%Note that in the absence of a concrete ISA this essentially amounts to having
%\emph{dependency fences}.

%{\color{blue} We note that no provision is made to restrict control
%dependencies: for example on Power or ARM a branch between two reads does not
%yield a control dependency (one needs to place an {\tt isync} (resp. {\tt isb})
%fence after the branch on Power (resp. on ARM) to create a dependency from read
%to read via a branch).  Is that intentional? Should we restrict {\tt ctrl}?}

\subsubsection{Global dependence order}

The document then defines the ``global dependence order'' as
the irreflexive transitive closure of \ldo{} union \coh{},
which we write
\begin{verbatim}
let gdo = (ldo|coh)+
\end{verbatim}

The document then states
``\emph{By rule, there cannot be a cycle in \gdo{}}'', which we interpret as a
requirement: \gdo{} must be acyclic.

\begin{verbatim}
acyclic gdo as GdoCons
\end{verbatim}

\subsubsection{No thin air}

It seems to us that requiring {\tt gdo} acyclic aims at forbidding \emph{out of
thin air} values, as illustrated by the typical example ``\ltst{lb+ldos}'':
\begin{figure}[!h]
\begin{center}
\moveback\fmt{lb+ldos}
\end{center}
\caption{The load buffering test with {\tt ldos} on both threads
\color{red}{(Forbidden)}}
\end{figure}

See also:
\url{virginia.cs.ucl.ac.uk/?record=hsa&cat=hsa&bell=hsa&litmus=lb+ldos}.
%{\color{blue} We have several questions on that topic:
%\begin{itemize}
%\item Is that right, that the intent is to forbid out of thin air values?
%\item How about placing fences in between the read-write pairs on each
%thread, should that forbid the LB behaviour above?
%\item How about having one step of {\tt ldo} then an internal {\tt coh} step on
%	each thread, should that forbid the LB behaviour? And the other way
%	around? One step of internal {\tt coh} then one step of {\tt ldo} on
%	each thread, should that forbid the LB behaviour?
%\end{itemize}}

% {\color{blue} Let us investigate each of these items in more details:
% 
% \paragraph{Fences}
% 
% Consider this fenced variant of the LB test:
% \begin{verbatim}
% Bell LB+fences 
% {
% x = 0;
% y = 0;
% }
%  P0                              | P1                              ;
%  r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
%  f[...]                          | f[...]                          ;  
%  w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
% 
% scopes:
% (system (agent (wg (wave (wi P0)) (wave (wi P1)))))
% 
% regions: x:global, y:global
% 
% ~exists (0:r1=1 /\ 1:r2=1)
% \end{verbatim}
% 
% Are there any tags we can put on the fences that would forbid the weak
% behaviour of this test (viz the case where both registers hold the value $1$ in
% the end)? We're wondering about both memory order and scope tags. Also, under
% what scope tree or scope instances?
% 
% More generally, should {\tt ldo} include something along the lines of:
% \begin{verbatim}
% (po & (_ * (F & Tag));po) & same-instance('tag)
% \end{verbatim}
% 
% \paragraph{Interaction of {\tt ldo} and {\tt coh}}
% 
% 
% More generally, should {\tt ldo} include something along the lines of:
% \begin{verbatim}
% po-loc 
% \end{verbatim}
% 
% alternatively: 
% \begin{verbatim}
% coh & ~ext
% \end{verbatim}
% 
% For example, consider this variant of the LB test (where {\tt dep} stands for
% ``dependency'', and could be any of {\tt addr, data} or {\tt ctrl}):
% 
% \pagebreak
% 
% \begin{verbatim}
% Bell LB+dep-cohWW+dep
% {
% x = 0;
% y = 0;
% }
%  P0                              | P1                              ;
%  r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
%  f[dep]                          | f[dep]                          ;  
%  w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
%  w[ordinary,rlx,wi,single] y 2   |                                 ;
% scopes:
% (system (agent (wg (wave (wi P0)) (wave (wi P1)))))
% 
% regions: x:global, y:global
% 
% ~exists (0:r1=1 /\ 1:r2=2)
% \end{verbatim}
% 
% Should the weak behaviour of LB be forbidden in this case? Namely the one where
% {\tt r2} on {\tt P1} holds $2$ and {\tt r1} on {\tt P0} holds $1$ at the end.
% 
% Or this variant:
% \begin{verbatim}
% Bell LB+dep-cohRW+dep
% {
% x = 0;
% y = 0;
% }
%  P0                              | P1                              ;
%  r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
%  f[dep]                          | f[dep]                          ;  
%  r[ordinary,rlx,wi,single] r3 y  | w[ordinary,rlx,wi,single] x 1   ;
%  w[ordinary,rlx,wi,single] y 1   |                                 ;
% scopes:
% (system (agent (wg (wave (wi P0)) (wave (wi P1)))))
% 
% regions: x:global, y:global
% 
% ~exists (0:r1=1 /\ 1:r2=1)
% \end{verbatim}
% 
% Should the weak behaviour of LB be forbidden in this case? Namely the one where
% {\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.
% 
% \pagebreak
% 
% Or this variant:
% \begin{verbatim}
% Bell LB+dep-cohRW-cohWW+dep
% {
% x = 0;
% y = 0;
% }
%  P0                              | P1                              ;
%  r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
%  f[dep]                          | f[dep]                          ;  
%  r[ordinary,rlx,wi,single] r3 y  | w[ordinary,rlx,wi,single] x 1   ;
%  w[ordinary,rlx,wi,single] y 1   |                                 ;
%  w[ordinary,rlx,wi,single] y 2   |                                 ;
% scopes:
% (system (agent (wg (wave (wi P0)) (wave (wi P1)))))
% 
% regions: x:global, y:global
% 
% ~exists (0:r1=1 /\ 1:r2=2)
% \end{verbatim}
% 
% Should the weak behaviour of LB be forbidden in this case? Namely the one where
% {\tt r2} on {\tt P1} holds $2$ and {\tt r1} on {\tt P0} holds $1$ at the end.
% 
% Or this variant:
% \begin{verbatim}
% Bell LB+dep-cohRR-dep+dep
% {
% x = 0;
% y = 0;
% }
%  P0                              | P1                              ;
%  r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
%  f[dep]                          | f[dep]                          ;  
%  r[ordinary,rlx,wi,single] r3 z  | w[ordinary,rlx,wi,single] x 1   ;
%  r[ordinary,rlx,wi,single] r4 z  |                                 ;
%  f[dep]                          |                                 ;  
%  w[ordinary,rlx,wi,single] y 1   |                                 ;
% scopes:
% (system (agent (wg (wave (wi P0)) (wave (wi P1)))))
% 
% regions: x:global, y:global
% 
% ~exists (0:r1=1 /\ 1:r2=1)
% \end{verbatim}
% 
% Should the weak behaviour of LB be forbidden in this case? Namely the one where
% {\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.
% 
% \pagebreak
% 
% Or this variant:
% \begin{verbatim}
% Bell LB+cohRR-dep+dep
% {
% x = 0;
% y = 0;
% }
%  P0                              | P1                              ;
%  r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
%  r[ordinary,rlx,wi,single] r3 x  |                                 ;
%  f[dep]                          | f[dep]                          ;  
%  w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
% scopes:
% (system (agent (wg (wave (wi P0)) (wave (wi P1)))))
% 
% regions: x:global, y:global
% 
% ~exists (0:r1=1 /\ 1:r2=1)
% \end{verbatim}
% 
% Should the weak behaviour of LB be forbidden in this case? Namely the one where
% {\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.
% 
% Or this variant:
% \begin{verbatim}
% Bell LB+cohRW-cohWR-dep+dep
% {
% x = 0;
% y = 0;
% }
%  P0                              | P1                              ;
%  r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
%  w[ordinary,rlx,wi,single] x 1   |                                 ; 
%  r[ordinary,rlx,wi,single] r3 x  |                                 ;
%  f[dep]                          | f[dep]                          ;  
%  w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
% scopes:
% (system (agent (wg (wave (wi P0)) (wave (wi P1)))))
% 
% regions: x:global, y:global
% 
% ~exists (0:r1=1 /\ 1:r2=1)
% \end{verbatim}
% 
% Should the weak behaviour of LB be forbidden in this case? Namely the one where
% {\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.}
% 
%\pagebreak

\subsubsection{Write-to-read causality}

We observe that the definition of {\tt gdo} as is forbids \ltst{wrc+ldos}:

\begin{figure}[!h]
\begin{center}
\moveback\fmt{wrc+ldos}
\end{center}
\caption{The write-to-read causality test with {\tt ldos} \color{red}{(Forbidden)}}
\end{figure}

See also:
\url{virginia.cs.ucl.ac.uk/?record=hsa&cat=hsa&bell=hsa&litmus=wrc+ldos}.
% {\color{blue} Is that intentional? If the intent of requiring {\tt gdo} acyclic
% is only to forbid out of thin air values, then {\tt gdo} could be simplified,
% and only include a fragment of {\tt coh}. More precisely {\tt gdo} could
% include {\tt rfe}, viz the \rf{} relation when source and target belong to
% different units (below the pre-defined relation {\tt ext} gathers pairs of
% events from different units):
% \begin{verbatim} 
% let rfe = rf & ext
% let gdo = (ldo | rfe)+
% acyclic gdo as GdoCons
% \end{verbatim}
% 
% Or even, omitting the transitive closure: {\tt let gdo = ldo | rfe}. Indeed
% taking the transitive closure doesn't change anything when requiring {\tt gdo}
% to be acyclic, and {\tt gdo} is never used later in the model.
% 
% Note (see the event tags in the figure above) that all memory accesses in test
% \ltst{wrc+ldos} are atomic relaxed.  Furthermore, the pictured execution
% validates the coherence constraints (our section~\ref{coherence}) and, provided
% the three units~\myth{0}, \myth{1} and~\myth{2} are in the same work-group, the
% execution is not racy.  Hence, there are no further constraints on this
% execution and the test being allowed or forbidden depends exclusively on the
% definition of \texttt{gdo}.  More precisely with \texttt{gdo} being
% \verb!(ldo|coh)+! the test is forbidden; with \texttt{gdo} being
% \verb!(ldo|rfe)+! the test is allowed.}
% 
% Assuming this is the intent, let us revisit similar questions to the LB ones on
% the WRC test case. 
% 
% \pagebreak
% 
% {\color{blue} Consider the following variant of WRC:
% {\footnotesize
% \begin{verbatim}
% Bell wrc+fence+dep
% {
% 2:r1=-1;
% }
% P0                          | P1                           | P2                           ;
% w[atomic,rlx,wg,single] x 1 | r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
%                             | f[...]                       | bne r0, 1, Exit2             ;
%                             | w[atomic,rlx,wg,single] y 1  | r[atomic,rlx,wg,single] r1 x ;
%                             |                              | Exit2:                       ;
% exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
% \end{verbatim}
% }
% 
% Are there any tags we can put on the fence on {\tt P1} that would forbid the
% weak behaviour of this test (viz the case where on {\tt P1} {\tt r0} holds $1$,
% i.e. {\tt P1} has read from {\tt P0}, and on {\tt P2} {\tt r0} holds $1$, i.e.
% {\tt P2} has read from {\tt P1}, and finally on {\tt P2} {\tt r1} holds $0$,
% meaning {\tt P2} has read $x$ from the initial state)? We're wondering about
% both memory order and scope tags. Also, under what scope tree or scope
% instances?
% 
% And what about this variant:
% {\footnotesize
% \begin{verbatim}
% Bell wrc+dep+fence
% {
% 2:r1=-1;
% }
%  P0                          | P1                           | P2                           ;
%  w[atomic,rlx,wg,single] x 1 | r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
%                              | bne r0, 1, Exit1             | f[...]                       ;
%                              | w[atomic,rlx,wg,single] y 1  | r[atomic,rlx,wg,single] r1 x ;
%                              | Exit1:                       |                              ;
% exists
% (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
% \end{verbatim}
% }
% 
% Are there any tags we can put on the fence on {\tt P2} that would forbid the
% weak behaviour of this test (viz the case where on {\tt P1} {\tt r0} holds $1$,
% i.e. {\tt P1} has read from {\tt P0}, and on {\tt P2} {\tt r0} holds $1$, i.e.
% {\tt P2} has read from {\tt P1}, and finally on {\tt P2} {\tt r1} holds $0$,
% meaning {\tt P2} has read $x$ from the initial state)? We're wondering about
% both memory order and scope tags. Also, under what scope tree or scope
% instances?}
% 
%\subsubsection{Distributed S shape}
%
%We observe that the definition of {\tt gdo} as is forbids
%\ltst{distributed-S+deps}:
%{\footnotesize
%\begin{verbatim}
%Bell distributed-S+deps
%{
%2:r1=-1;
%}
%P0                          | P1                           | P2                           ;
%w[atomic,rlx,wg,single] x 2 | r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
%                            | f[dep]                       | f[dep]                       ;
%                            | w[atomic,rlx,wg,single] y 1  | w[atomic,rlx,wg,single] x 1  ;
%exists (1:r0=2 /\ 2:r0=1 /\ x=2)
%\end{verbatim}
%}
%
%{\color{blue} Is that intentional? If the intent of requiring {\tt gdo} acyclic
%is only to forbid out of thin air values, then {\tt gdo} could be simplified,
%along the lines of what we write above.}
%

\pagebreak
\subsection{Heterogeneous happens-before}

\subsubsection{Scoped synchronisation order \label{sso}}

We can now define scoped synchronisation orders, which we believe essentially
formalise release-acquire synchronisation, with scope restrictions. 

Recall that \prog{herd} builds pre-defined sets of tagged events; for example
{\tt Screl} is the set of events bearing the tag {\tt screl}. From these sets,
we build a few relevant sets:
\begin{verbatim}
let Release = Screl | Scar
let Acquire = Scacq | Scar
let Synchronizing = Acquire | Release
\end{verbatim}

Note that the \texttt{screl}, \texttt{scacq} and~\texttt{scar} tags apply to
atomic operations and to fences only. As a consequence, the above sets regroup
atomic operations and fences only.

To build the scoped synchronisation order, we follow the documentation (Section
3.9), up to a few minor changes that we detail below:
\begin{verbatim}
let acq-rel =
  (((W | RMW) & Release) * ((R | RMW) & Acquire)) & coh
| ((F & Release) * Acquire) &
  ((po & (_ * (W | RMW))); coh; (po? & ((R | RMW) * _)))
| (Release * (F & Acquire)) &
  ((po? & (_ * (W | RMW))); coh; (po & ((R | RMW) * _)))

let sso(tag) = same-instance(tag) & acq-rel
\end{verbatim}

Note that we do not impose for the intermediate $A$ and~$B$ operations (the
ones such that $A \coh B$) to be atomic accesses in the last two cases.
Although this is a race, we did not find this to be specified in the HSA
document. %{\color{blue} Is that intentional?}

The definition of \texttt{acq-rel} gathers the three top-level items of the
description of the HSA document.  It uses set and relation constructs
intensively, most of which have already been introduced, except the ``optional
step'' operator~\texttt{$e$?} that yields, \texttt{$e$|id} (\emph{i.e.} $e$
union the identity relation), and the universe set ``\verb+_+'' that contains
all events (even fence events).

Our (minor) changes w.r.t. the HSA documentation are:
\begin{itemize}
\item we do not specify the accesses to be synchronising or atomic, as our
\texttt{Acquire} and \texttt{Release} sets contain synchronising
operations~only;
%\item we make no specific provision for
%RMW operations as they are represented by a read event (in~\verb+R+)
%and a write event (in \verb+W+) (see our section~\ref{rmw});
\item we made the definition a bit more symmetric (and redundant) by having the
third item produce fence-to-fence order, as the second item does;

\item we have factored out the condition ``\emph{$X$ and~$Y$ both specify the
same instance~$S$}'' (implemented by the call to ``\verb+same-instance(s)+'').
\end{itemize}

\pagebreak

\paragraph{An example: ISA2}

As an illustration, let us examine the test~\ltst{isa2}:
{\footnotesize
\verbatiminput{img/isa2+coh}
}

Below in Figure~\ref{isa2coh} we consider a particular execution candidate of
the test~\ltst{isa2}, viz a certain~\rf{} relation and a certain~\coh{}
relation:
\begin{figure}[!h]
\begin{center}\fmt{isa2+coh}
\end{center}
\caption{\label{isa2coh}An execution candidate of the test~\ltst{isa2} \color{green}{(Allowed)}}
\end{figure}
%{\color{blue} Does this picture match the intent?}

See also
\url{virginia.cs.ucl.ac.uk/?record=hsa&cat=hsa&bell=hsa&litmus=isa2}.

More precisely,
\begin{itemize}
\item given the condition \verb+exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)+ of the
test, we select an execution where the read from~\texttt{y} by the
unit~\myth{1} reads the value \texttt{1}, which is stored to~\texttt{y} by the
unit~\myth{0}.  Hence, we select an execution where $b \rf c$.  Similarily we
select $d \rf e$.  Finally we consider that the event~$f$ reads the initial
value of~\texttt{x}, which is pictured by a red~\rf{} arrow from the
``initial'' event  (top of figure) to event~$f$.

\item We select some \coh{} relation that passes the coherence checks of
section~\ref{coherence}.  For clarity of the picture, we do not show the
complete \coh{} relation but a sub-relation (essentially edges that can be
deduced by transitivity are omitted).  The significant pairs of this \coh{}
relation are $b \coh c$, $d \coh e$ (which are the same as inter-unit \rf{}
pairs), and $f \coh a$ which originates from event~$f$ reading the initial
value of~\texttt{x}, which implies that the event $f$  is \coh-before all
writes to~\texttt{x} performed by all the units of the test.
\end{itemize}

\paragraph{An illustration of sso on ISA2}

Now that we have defined \coh{}, we can compute scope synchronisation orders.
Figure~\ref{isa2sso} shows the scope synchronisation orders for scopes agent
and work-group, for the test ISA2.
\begin{figure}[!h]
\begin{center}\moveback\fmt{isa2+sso}
\end{center}
\caption{\label{isa2sso}Scope synchronisation orders for scopes agent (\textsf{sso-agent}) and work-group (\textsf{sso-wg}) \color{green}{(Allowed)}}
\end{figure}

See also
\url{virginia.cs.ucl.ac.uk/?record=hsa&cat=hsa&bell=hsa&litmus=isa2}.

%{\color{blue} Does this picture match the intent?}
Observe that the pair~$b \sso{wg} c$ results from the first case of the
definition of \verb+acq-rel+, namely 
\verb+((W & Release) * (R & Acquire)) & coh+, 
as $b$ is a write release (tag~\texttt{screl} in Figure~\ref{isa2sso}) and $c$
is a read acquire (tag~\texttt{scacq}).

Furthermore, we have $b \coh c$ (Figure~\ref{isa2coh}), thus the pair~$(b,c)$
is part of \texttt{acq-rel}.  Finally, events $b$ and $c$ specify the same
scope instance of level work-group, as illustrated by the pair $b \same{wg} c$
depicted in Figure~\ref{isa2same}.

Hence,  we have $b \sso{wg} c$, since we defined $\sso{wg}$ as the intersection
of the relations \texttt{acq-rel} and $\same{wg}$ (implemented as
\texttt{same-instance('wg)}).

\subsubsection{Heterogeneous happens-before \label{sec:hhb}}

Following the HSA~document, we define the HSA happens-before order~\hhb{} as
the transitive closure of the union of the program order and of the union of
scope synchronisation order for all scopes:
\begin{verbatim}
let union-scopes f = fold (fun (s,y) -> f s | y) (scopes,{})

let hhb = (po | union-scopes sso)+
\end{verbatim}

The function \texttt{union-scopes} takes a function {\tt f} as argument.  This
function {\tt f} should go from scope tags to relations, typically just like
\texttt{sso}.

The function \texttt{union-scopes} returns the union of the
\texttt{$f(\text{tag})$} for all scope tags.  It refers to the \texttt{scopes}
tag set, which is implicitly defined by the \verb+enum scopes = +\ldots{}
definition, and to the \verb+fold+ (over sets) function, defined in
appendix~\ref{coh}.

In the case of the test~\ltst{isa2} we get the \hhb{} relation pictured
in figure~\ref{isa2hhb}.
\begin{figure}
\begin{center}\fmt{isa2+hhb}
\end{center}
\caption{\label{isa2hhb} The HSA happens-before relation for test~\ltst{isa2} \color{red}{(Forbidden)}}
\end{figure}
Edges that result from the transitivity of~\hhb{} are omitted. In particular
the pair $a \hhb f$ is omitted. 
%{\color{blue} Does this picture match the intent?}

See also: \url{virginia.cs.ucl.ac.uk/?record=hsa&bell=hsa&cat=hsa&litmus=isa2}.

Now, the HSA document defines three validity conditions on~\hhb.  The \hhb{}
relation must be acyclic (equivalently irreflexive, as \hhb{} is transitive),
consistent with \coh{}, and consistent with sequentially consistent orders
(which we shall see in the next section).
We express the first two conditions as follows:
\begin{verbatim}
irreflexive hhb as HhbCons
call consistent (hhb,coh) as HhbCohCons
\end{verbatim}
Note that Figure~\ref{isa2hhb} illustrates a case of inconsistency of \hhb{}
and~\coh{}: $a \hhb f \coh a$. And indeed, our \ltst{isa2} test is
similar to the test ``Race-free transitive synchronisation through multiple
scopes'' of the HSA document (replacing \texttt{while} loops by \texttt{if}
constructs). It should thus be forbidden.

\subsection{Sequentially consistent synchronisation order \label{sc-orders}}
Sec. 3.10 of the HSA document states: ``\emph{there is a total (apparent) order
of all synchronising operations with release, acquire, or acquire-release
semantics in a single scope instance}''.  Given a scope instance~$S$, we write
$\SCS{S}$ for this total order, and $\SCLVL{tag}$ for the union of  $\SCS{S}$
orders for all scope instances at level~\text{tag}. We also abbreviate
sequentially consistent synchronisation order as ``SC order''.

The \cat{} primitive \texttt{classes} takes an equivalence relation as argument
and returns its equivalence classes as a set of sets of events. Hence we can
compute the set of all scope instances~$S$ for a given level~\text{tag}
as follows:
%\marginpar{Luc for Jade, all
%our models use \texttt{same-instance} in place of \texttt{tag2scope}\ldots}

\begin{verbatim}
let sync-instances(tag) =
  classes ((Synchronizing * Synchronizing) & same-instance(tag))
\end{verbatim}
The function~\verb+sync-instance+ takes a scope tag as argument and returns
a set of sets of events, each set of events being a scope instance.

%{\color{blue} Here we could also use {\tt same-instance(lvl)}, which also takes
%into account the scope tags on the synchronisation operations ordered by {\tt
%sync-instances(lvl)}. What is the intent here? Note that choosing {\tt
%tag2scope(lvl)} makes checking the consistency of SC orders wrt one another
%somewhat superfluous, because the domain and range of each SC order are
%included in the domain and range of the wider SC orders, whereas with {\tt
%same-instance} it does not.}

Then, the HSA  document clearly states that the total order $\SC{$S$}$
extends \po{}: ``\emph{Given synchronisation operations $X$ and~$Y$, if $X \po Y$ and $X$ and~$Y$ specify the same scope instance~$S$ (directly or indirectly
through inclusivity), then $X \SC{$S$} Y$}''.
However it is unclear if this applies to any pair of synchronising operations
that belong to~$S$, or only to those whose scope annotations take effect
at the level of~$S$. 
%\fixme{jade: je comprends pas la difference}
%Nevertheless, as $\SC{$S$}$ is total and later required to be consistent
%with $\po$ it does not matter much. 
We choose the first, more simple, interpretation. Hence given a scope
instance~$S$, we compute the set of $\po$ linearisation on~$S$ as follows:
\begin{verbatim}
let preSC = po
let makeSCinstance(S) = linearisations(S,preSC)
\end{verbatim}
The \texttt{linearisation($S$,$r$)} primitive that computes all topological sorts of the graph $(S \times r)$ is introduced in appendix~\ref{coh}.
Finally, we compute the set of all possible $\SCLVL{tag}$ relations as:
\begin{verbatim}
let makeSCscope(tag) = cross (map makeSCinstance (sync-instances(tag)))
\end{verbatim}
The function~\texttt{map} is map over sets. In the code above it serves
to compute the set of the sets of all possible $\SCS{S}$ orders
for all scope instances~$S$ at level~\text{tag}.
The function~\texttt{cross} takes a set of sets $\{S_1,S_2,\ldots,S_n\}$ as
argument and returns its \emph{cross product}, i.e. the set of all sets built
by picking one element in each~$S_i$. Those two functions are introduced in
appendix~\ref{coh}.

%{\color{blue} To help us settle these questions on SC orders, it'd be helpful
%to know whether two synchronising operations by the same unit, bearing the
%annotation work-group should be ordered by the SC order of their scope instance
%of level agent.}

%\includegraphics[width=10cm]{cross}

Finally, we iterate over all possible choices of $\SCLVL{tag}$ for the five
HSA scope levels as follows\footnote{A different, more generic,
coding as a loop over the set of scope tags \texttt{scopes} is possible.
We found it to be a bit obfuscated and refrain from presenting it.}: 
%\fixme{jade@Luc: pour la presentation dans ce document, est-ce qu'on pourrait
%mettre tout ca dans une procedure, avec un forall?}
\begin{verbatim}
with SWI from makeSCscope('wi)
call consistent(SWI,coh) as ScCohCons
call consistent(SWI,hhb) as ScHhbCons
with SWAVE from makeSCscope('wave)
call consistent(SWAVE,coh) as ScCohCons
call consistent(SWAVE,hhb) as ScHhbCons
with SWG from makeSCscope('wg)
call consistent(SWG,coh) as ScCohCons
call consistent(SWG,hhb) as ScHhbCons
with SAGENT from makeSCscope('agent)
call consistent(SAGENT,coh) as ScCohCons
call consistent(SAGENT,hhb) as ScHhbCons
with SSYSTEM from makeSCscope('system)
call consistent(SSYSTEM,coh) as ScCohCons
call consistent(SSYSTEM,hhb) as ScHhbCons
\end{verbatim}
Notice that we also check the consistency of SC orders with \coh{} and \hhb{},
as required, but not with~\po{}.  Indeed, by construction the ``order''
\SCLVL{tag} includes~\po{} and the two relations are thus consistent.  It
remains to check that the SC orders are pairwise consistent:
%\marginpar{Luc to Jade, unclear whether omitting the \texttt{ScSc}
%checks will impact valid candidates or not.}
%\fixme{jade@Luc: pour la presentation dans ce document, est-ce qu'on pourrait
%mettre tout ca dans une procedure, avec un forall?}
\begin{verbatim}
call consistent(SWI,SWAVE) as ScSc
call consistent(SWI,SWG) as ScSc
call consistent(SWI,SAGENT) as ScSc
call consistent(SWI,SSYSTEM) as ScSc
call consistent(SWAVE,SWG) as ScSc
call consistent(SWAVE,SAGENT) as ScSc
call consistent(SWAVE,SSYSTEM) as ScSc
call consistent(SWG,SAGENT) as ScSc
call consistent(SWG,SSYSTEM) as ScSc
call consistent(SAGENT,SSYSTEM) as ScSc
\end{verbatim}

\paragraph{An example: SB}

As an example, we consider the following test~\ltst{sb}:
\verbatiminput{img/sb.litmus}
The final proposition \verb+(0:r0 = 0 /\ 1:r0 = 0)+ corresponds
to the \rf{} and \coh{} relations depicted in Figure~\ref{sbcoh}.
\begin{figure}[!h]
\vspace*{-2mm}
\begin{center}\moveback\fmt{sb}
\end{center}
\vspace*{-8mm}
\caption{\label{sbcoh}The non-SC execution of test~\ltst{sb} \color{green}{(Allowed)}}
\end{figure}
See also \url{virginia.cs.ucl.ac.uk/?record=hsa&bell=hsa&cat=hsa&litmus=sb}.

The execution is not sequentially consistent, since there is a cycle in $\po
\cup \coh$. As a result there is no total order that would be consistent with
$\po$ and $\coh$.

The scope tree specification of the test states that the two units of the test
are in the same work group. As a result, all events (which are synchronising
and specify scope work-group) live in the same work-group scope instance.
There is no SC order at the  work-group level. Thus figure~\ref{sbwg} shows a
contradiction between the workgroup SC order SWG and \coh{}.
\begin{figure}[!h]
\vspace*{-2mm}
\begin{center}\moveback\fmt{sb+wg}
\end{center}
\vspace*{-2mm}
\caption{\label{sbwg}Contradiction of the work-group SC order and coh \color{red}{(Forbidden)}}
\end{figure}
See also \url{virginia.cs.ucl.ac.uk/?record=hsa&bell=hsa&cat=hsa&litmus=sb}.

One may observe that the pictured $\SC{wg}$ order contradicts \coh{} on
the pair $(a,d)$.

By contrast, the events of each unit can be ordered independently in each
work-item instance, as show in Figure~\ref{sbwi}.  Indeed the SWI order is
consistent with \po{} (in fact is equal to) and also with \coh{} restricted to
each scope instance, which happen to be empty.
\begin{figure}[!h]
\vspace*{-2mm}
\begin{center}\moveback\fmt{sb+wi}
\end{center}
\vspace*{-2mm}
\caption{\label{sbwi}A successful ordering of the two work-item scope instances \color{green}{(Allowed)}}
\end{figure}
See also \url{virginia.cs.ucl.ac.uk/?record=hsa&bell=hsa&cat=hsa&litmus=sb}.

\pagebreak

\section{Races}
The HSA document has two definitions of conflicts: ordinary and special.
Ordinary conflicts are defined as follows:
``\emph{Two operations $X$ and~$Y$ conflict, iff they access one or
more common byte locations, at least one is a write, and at least one is
an ordinary data operation}''.
Having noticed that ``conflicts'' forms a symmetric relation, we paraphrase
the definition:
\begin{verbatim}
let at-least-one a = (a * _) | (_ * a)

let ordinary-conflicts = loc & at-least-one(W) & at-least-one(Ordinary)
\end{verbatim}
We use the pre-defined relation \verb+loc+ that relates accesses to the same
location, and two pre-defined sets of events: \verb+W+ the set of write
operations, and \verb+Ordinary+ the set of ordinary data operations.

\label{specialconflict}The HSA document defines special conflicts as follows:
\begin{quote}\em
Two special operations $X$ and~$Y$ conflict iff $X$ and $Y$ access
the same byte location and:
\begin{itemize}
\item[35.] $X$ and~$Y$ are different sizes (e.g., 32-bit vs. 64-bit), or
\item[36.] At least one is a write (or a read-modify-write),
and $\neg(\textit{Match}(\textit{SI}(X), \textit{SI}(Y))$.
\end{itemize}
\end{quote}
Condition~36 refers to a (negated) \textit{Match} predicate and to
a~\textit{SI} function.  Both are defined in the ``Scope instances'' section of
the HSA document.

The function~\textit{SI} returns the set of scope instances specified by an
operation, and the \textit{Match} predicate tests the non-emptiness of the
intersection of these scope instances. In Section~\ref{sso} we have defined the
relation~\texttt{same-instance('\text{tag})} that relates events that specify
a common scope instance at level~\text{tag}. Hence, we
represent~\textit{Match} by the relation~\verb+matches+ that relates events
specifying a common scope instance at some level.  In effect, we quantify over
scope levels rather than on pairs of operations and  define \verb+matches+ as
the union of \texttt{same-instance('\text{tag})} for all scope levels. In
\cat{} we write: \begin{verbatim} let matches = union-scopes same-instance

let special-conflicts =
  (loc & (~same-size | Atomic * Atomic) & at-least-one(W)) \ matches
\end{verbatim}
The function~\verb+union-scopes+ that returns the union of
the application of a function on all scope tags is defined
in our Sec.~\ref{sso}. 

The definition of HSA conflicts lacks an additional condition:
accesses have to be by different units, which we consider in
the definition of conflicts below, by the means of the pre-defined~\verb+ext+
relation that relates operations by different units:
\begin{verbatim}
let conflicts = ((ordinary-conflicts|special-conflicts) & ext) \ at-least-one(IW)
\end{verbatim}
We have also added that initial writes (pre-defined set~\verb+IW+)
do not contribute to conflicts.
%As a matter of fact \herd{} considers the initial value of a location to come
%from an explicit initial write operation, for the $\rf$ relation to be defined
%on all read operations.

We then define races as conflicts that are not ordered by HSA happens-before,
in either direction (which we believe to be another omission of the HSA
document):
\begin{verbatim}
let hsa-race = conflicts \ (hhb | hhb^-1)
\end{verbatim}
We used the postfix~$r\texttt{\^{}-1}$ operator that evaluates to
the inverse of relation~$r$.

We inform the \prog{herd} tool about races using with the \texttt{flag}
construct, which apply to all checks.  The normal behaviour for a check is to
stop model execution when invalid.  By contrast, a failing flagged check does
not stop execution but instead ``flags'' it with an arbitrary flag (here
\verb+undefined+).

Flags are recorded and handed over to the \prog{herd} machinery at the end of
model execution --- hence for valid executions that passed all (unflagged)
checks.  The \prog{herd} tool can then decide that the simulated program is
undefined, as soon as one of the valid executions has been flagged as
\verb+undefined+.
\begin{verbatim}
flag ~empty hsa-race as undefined
\end{verbatim}
Observe that the execution is flagged when the \verb+hsa-race+ relation is
\emph{not} empty.

\pagebreak

\section{Cat file}

We gather all the definitions over relations and orders in a {\tt cat} file,
which we give below.

We first give util definitions, e.g. {\tt map} or {\tt fold}, gathered in the file {\tt hsa-lib.cat}:
\verbatiminput{hsa-lib.cat}

\pagebreak

Then the main body of the model ({\tt hsa.cat}):
\verbatiminput{hsa.cat}

\pagebreak

And then the definitions relative to races ({\tt hsa-race.cat}):
\verbatiminput{hsa-race.cat}


\pagebreak

\section{Tests from the documentation}

Here we gather the examples given in the documentation, together with a picture
of a forbidden execution, and a link to the web interface of the {\sf herd}
simulator of our HSA model.

\subsection{Synchronizing operations are sequentially consistent by definition}
\begin{multicols}{2}
\verbatiminput{img/HSA01.litmus}
\end{multicols}
\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA01}
\end{center}
\caption{\label{hsa01} \ltst{HSA01} is forbidden by the consistency
of \SC{wg} and \coh{} \color{red}{(Forbidden)}}
\end{figure}

On the web:

\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA01}

\pagebreak

\subsection{Synchronization between units of execution}
\verbatiminput{img/HSA02.litmus}

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA02}
\end{center}
\caption{\label{hsa02} \ltst{HSA02} is forbidden by the consistency
of \hhb{} and \coh{} \color{red}{(Forbidden)}}
\end{figure}

On the web:

\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA02}

\pagebreak

\subsection{Transitivity with a single scope}
\verbatiminput{img/HSA03.litmus}

\begin{figure}[H]
\begin{center}\moveback\fmt{HSA03}
\end{center}
\caption{\label{hsa03} \ltst{HSA03} is forbidden by the consistency
of \hhb{} and \coh{} \color{red}{(Forbidden)}}
\end{figure}

On the web:

\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA03}

\pagebreak

\subsection{\label{ex04}Synchronization through multiple scopes}
\verbatiminput{img/HSA04.litmus}
%{\color{blue}
%In the HSA document, all variables, including
%the variable~\texttt{z},
%are defined in the group segment. However
%the variable~\texttt{z} is used ti
%synchronize \myth{1} and~\myth{2}, which are not in the same work-group.
%This looks like a minor error.
%\noindent\textbf{NB:} As segments are not implemented yet
%in \herd{}, we assume global segment for all variables.}

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA04}
\end{center}
\caption{\label{hsa04} \ltst{HSA04} is forbidden by the consistency
of \hhb{} and \coh{} \color{red}{(Forbidden)}}
\end{figure}

On the web:

\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA04}

\pagebreak

\subsection{Synchronization through scope inclusion}
\verbatiminput{img/HSA05.litmus}

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA05}
\end{center}
\caption{\label{hsa05} \ltst{HSA05} is forbidden by the consistency
of \hhb{} and \coh{} \color{red}{(Forbidden)}}
\end{figure}

On the web:

\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA05}

\pagebreak

\subsection{Synchronization through scope inclusion and scope transitivity}
\verbatiminput{img/HSA06.litmus}
This example is quite similar to~\ltst{HSA04} (see Section~\ref{ex04}).
There are two differences:
\begin{itemize}
\item All variables of test~\ltst{HSA06} are in the global segments,
while they are in the group segment in example~\ltst{HSA04}
\item The
scope annotations of the read acquire operation on variable~\texttt{y} by
unit~\myth{1} (event~$c$ in figures~\ref{hsa04} and~\ref{hsa06}) differ:
 it is agent for~\ltst{HSA06} and work-group for~\ltst{HSA04}.
In that sense, this test~\ltst{HSA06} looks like
a combination of the two previous tests~\ltst{HSA04} and~\ltst{HSA05}.
\end{itemize}

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA06}
\end{center}
\caption{\label{hsa06} \ltst{HSA06} is forbidden by the consistency
of \hhb{} and \coh{} \color{red}{(Forbidden)}}
\end{figure}

On the web:

\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA06}

\pagebreak


\subsection{Coh and hhb must be consistent}

\verbatiminput{img/HSA07.litmus}
As expected the test~\ltst{HSA07} is forbidden by the consistency of \hhb{}
and~\coh (see Figure~\ref{hsa07}).  We observe that all the previous tests,
except~\ltst{HSA01}, illustrate the consistency of \hhb{} and~\coh{}.

On the web:

\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA07}

\begin{figure}[htp]
\caption{Test~\ltst{HSA07} is {\color{red}{forbidden}} by\ldots}
\begin{center}
\subfloat[\label{hsa07} \ldots{} the consistency of \hhb{}
and~\coh{}.]{\rule{2cm}{0cm}\fmt{HSA07}
\rule{2cm}{0cm}}

\vspace*{2cm}

\subfloat[\label{hsa07bis} \ldots or by value of a load.]{\fmt{HSA07+BIS}}
\end{center}
\end{figure}

One may remark that forbidding this test also results
from the value-of-a-load rule. Figure~\ref{hsa07bis} illustrate this point:
here the relations~\hhb{} and~\coh{} are consistent.
Yet the arrow $a \rf e$ violates value-of-a-load,
as the read~$e$ does not get its value from the most recent write in~\coh{}.

\pagebreak

%\subsection{Separate segment synchronization}
%{\color{blue} From our perspective there is a problem with this example. The
%HSA document comments ``The example shows that synchronisation can cross
%segments. Even though the atomic stores and loads specify a location in global
%memory, they still synchronise the group location~Y''. However the atomic
%stores and loads specify location~Y, which belongs to the group segment.
%Moreover, we still do not quite understand how memory segments fit in the
%memory model. See our remarks in Section~\ref{segment}.}
%\pagebreak

\subsection{Synchronization between units of execution using relaxed atomics}
\verbatiminput{img/HSA09.litmus}

This test illustrates successful synchronization by the means of fences (see
Figure~\ref{hsa09}).  It should perhaps be noted that in this scenarion, fences
are enough to restore~SC.  This would not be the case for test~\ltst{HSA12}
(Section~\ref{ex12}).

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA09}
\end{center}
\caption{\label{hsa09} \ltst{HSA09} is forbidden by the consistency
of \hhb{} and \coh{} \color{red}{(Forbidden)}}
\end{figure}

On the web:
\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA09}

\pagebreak

\subsection{Store speculation is not observable}
\verbatiminput{img/HSA10.litmus}

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA10}
\end{center}
\caption{\label{hsa10} \ltst{HSA10} is {\color{red}{forbidden}} by the
irreflexivity of~$\gdo{} = (\ldo \cup \rfe)^{+}$}
\end{figure}

On the web:
\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA10}

\pagebreak

\subsection{~No out-of-thin-air values}

\verbatiminput{img/HSA11.litmus}
This is the paradigmatic ``no values out-of-thin-air'' test.
As illustrated by Figure~\ref{hsa11}, our models reject this
tests by the irreflexivity check of~\gdo{}.
Observe that the value of events is a variable ``\textsf{S4}''.
This variable stands for just any integer value.

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA11}
\end{center}
\caption{\label{hsa11} Test~\ltst{HSA11} is {\color{red}{forbidden}} by the
irreflexivity of~$\gdo{} = (\ldo \cup \rfe)^{+}$}
\end{figure}

On the web:
\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA11}

\pagebreak

\subsection{\label{ex12}~Dekker's Algorithm}

\verbatiminput{img/HSA12.litmus}

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA12}
\end{center}
\caption{\label{hsa12} Test~\ltst{HSA12} is \color{green}{allowed}}
\end{figure}

On the web:
\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA12}

\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA12+fences}
\end{center}
\caption{\label{hsa12fences} Test~\ltst{HSA12+fences} is \color{green}{allowed}}
\end{figure}

On the web:
\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA12+fences}

\pagebreak

\subsection{~Conflict without synchronization}
\verbatiminput{img/HSA13.litmus}
This test illustrates an ordinary race.
There is no \hhb-induced order between events $a$ and~$b$, which
are to the same location, by different units, one event ($a$) being a write,
see~Figure~\ref{hsa13}.
\begin{figure}[htp]
\begin{center}\moveback\fmt{HSA13}
\end{center}
\caption{\label{hsa13} Test~\ltst{HSA13} is racy \color{blue}{(Racy)}}
\end{figure}

On the web:
\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA13}

\pagebreak

\subsection{~Insufficient scope}
\verbatiminput{img/HSA14.litmus}
This test illustrates a special race due to non-matching scopes.
Figure~\ref{hsa14} depicts two races: one is between atomic events~$b$ and~$c$
and stems from $b$ and~$c$ belonging to different work-groups, while bearing
the \texttt{wg} scope annotation.  More precisely, Figure~\ref{hsa14bis}
depicts the relations~\same{wg} and~\symr{matches}, which do \emph{not} relate
$b$ and~$c$.  And indeed, (see Section~\ref{specialconflict}) pairs related by
\symr{matches} are subtracted from potential special races.

Moreover, as a result of $b$ and~$c$ being in different work-groups,
the events $a$ and~$d$ are not ordered by \hhb (which reduces to~\po),
and we have a second (ordinary) race.
\begin{figure}[htp]
\begin{center}
\subfloat[\label{hsa14} Test~\ltst{HSA14} is racy.]{\fmt{HSA14}\rule{2cm}{0cm}}

\subfloat[\label{hsa14bis} Scopes for test~\ltst{HSA14}.]{\fmt{HSA14+SCOPE}}
\end{center}
\caption{Test~\ltst{HSA14} is \color{blue}{racy}}
\end{figure}

On the web:
\url{http://virginia.cs.ucl.ac.uk/herd/?record=hsa&bell=hsa&cat=hsa&litmus=HSA14}

%\input{extra-examples.tex}

\bibliographystyle{plain} \bibliography{hsa}

\end{document}


