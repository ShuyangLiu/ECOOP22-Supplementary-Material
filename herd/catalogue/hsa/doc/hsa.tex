\makeatletter
\@ifundefined{bwtrue}{\newif\ifbw\bwfalse}{}
\@ifundefined{acmtrue}{\newif\ifacm\acmtrue}{}
\makeatother
\makeatletter
\let\@period=\,
\makeatother
\documentclass[a4paper]{article}
\usepackage{xspace}
\usepackage{color}
\usepackage[leqno]{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{url}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{graphicx}
%\usepackage{rotating}
%\usepackage{adjustbox}
\usepackage{lscape}
\usepackage{subfig}
\usepackage{epsfig}
\usepackage{multicol}
\usepackage{float}
\usepackage[draft]{fixme}
\newif\ifcomments
\commentsfalse
\usepackage{url}
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\small\sf}}{\def\UrlFont{\small\sf}}}
\makeatother
\urlstyle{leo}
\usepackage[normalem]{ulem}
\input{macros}

\renewcommand{\topfraction}{0.9}
\begin{document}
\title{A note on HSA model(s)}
\author{Jade Alglave and Luc Maranget}
\maketitle
\let\prog\textsf

Our HSA model is phrased in terms of \emph{events} (e.g. reads and writes), and
relations over these events (e.g. program order, read-from \dots).

\section{Events}

Events can be \emph{accesses} (reads or writes\footnote{We model read-modify-write operations by two events.}), or
\emph{fences}. Events can bear \emph{tags}, for example relative to their
\emph{kind}, \emph{size}, \emph{memory order}, (i.e. the ordering constraints
they induce), or \emph{scope}. 

\subsection{Tags}

\subsubsection{Kind}

An event can be \emph{ordinary}, or \emph{atomic}, and bear the eponymous tag:
\begin{verbatim}
enum kind = 'ordinary || 'atomic
\end{verbatim}

\subsubsection{Size}

An event can be single-copy atomic, in which case it is tagged with {\tt
single} or not, in which case it is tagged with {\tt double}:
\begin{verbatim}
enum size = 'single || 'double
\end{verbatim}

Having the same size simply corresponds to bearing the same size tag:
\begin{verbatim}
let same-size = (Single*Single) | (Double*Double)
\end{verbatim}

\subsubsection{Memory order}

Memory orders are tags that induce certain ordering properties to the
events which bear them. Events can be \emph{relax} (tag {\tt rlx}),
\emph{acquire} (tag {\tt scacq}), \emph{release} (tag {\tt screl}), or both
release and acquire (tag {\tt scar}):
\begin{verbatim}
enum memory-order = 'rlx || 'scacq || 'screl || 'scar
\end{verbatim}

{\color{blue} We have several questions on the subject of memory order tags:
\begin{itemize}
\item there seems to be little difference (if any) between a read operation
annotated with scacq and a read operation annotated with scar (the same remark
applies to a write operation annotated with screl vs. scar). What is the
purpose of scacq and screl? For now we find they seem to act the same as scar
for reads and writes, respectively.
\item We model RMWs with a read and a write. Therefore we wonder what the
meaning of the tag scacq can be a RMW, as it is illegal for a write. The same
remark applies to tagging an RMW with screl, as screl is illegal for a read. 
\end{itemize}

}

\subsubsection{Scope}

Scope tags reflect the concurrency hierarchy; work-item events are tagged {\tt
wi}, and work-group events {\tt wg}, the other tags being eponymous of the
scope level: 
\begin{verbatim}
enum scopes = 'wi || 'wave || 'wg || 'agent || 'system
\end{verbatim}

\subsection{Accesses}

Accesses can be reads, writes or read-modify-writes, and bear various
combinatinons of the tags defined above.

\subsection{Reads}

Reads can be either ordinary or atomic, and this influences what size, memory
order, and scope tags they bear:
\begin{verbatim}
events R[{'ordinary},{'rlx},{'wi},size]
events R[{'atomic},{'rlx,'scacq,'scar},scopes,size]
\end{verbatim}

Thus reads can be ordinary, in which case they have to be relaxed and at scope
work-item; ordinary reads can be single-copy atomic or not. {\color{blue} Or do
they have to be single-copy atomic?}

Atomic reads can be relaxed, acquire, or release-acquire, and live at any scope
level, with any size.

\subsection{Writes}

Reads can be either ordinary or atomic, and this influences what size, memory
order, and scope tags they bear:
\begin{verbatim}
events W[{'ordinary},{'rlx},{'wi},size]
events W[{'atomic},{'rlx,'screl,'scar},scopes,size]
\end{verbatim}

Thus writes can be ordinary, in which case they have to be relaxed and at scope
work-item; ordinary writes can be single-copy atomic or not. {\color{blue} Or
do they have to be single-copy atomic?}

Atomic writes can be relaxed, acquire, or release-acquire, and live at any scope
level, with any size.

\subsection{Read-modify-writes}

Read-modify-writes have to be atomic, and can bear any memory order, scope or
size tags:
\begin{verbatim}
events RMW[{'atomic},memory-order,scopes,size]
\end{verbatim}

\subsection{Fences}

Fence events can bear memory order or scope tags:
\begin{verbatim}
events F[{'scacq,'screl,'scar},scopes]
\end{verbatim}

\section{\label{segment}Segments}

{\color{blue} We have several questions on the subject of memory segments:
\begin{itemize}
\item In the documentation, example ``Race­free transitive synchronization
through multiple scopes'': we are a bit surprised by the fact that variable Z
is defined in the group segment, as it is used for synchronisation between
units B and C, which belong to different groups. Is that intentional?
\item In the documentation, example ``Separate Segment synchronisation'': the
program declares X as global and Y as group. Essentially, the test seems to be
a release-acquire idiom using Y as flag and X as data. Hence we're not too sure
how to understand the final comment: ``This example shows that synchronization
can cross segments. Even though the atomic store  and load specify a location
in global memory, they still synchronize the group location Y.'' Are the atomic
store and load the ones over X, or Y?
\item Moreover, about the same example, the group variable Y is initialised to
$0$, whereas the HSAIL documentation seems to say that one cannot initialise
group variable; is that ok?
%\fixme{jade@Luc: je comprends pas le probleme ici?  Le test dit que X est
%global et Y est group (au passage Y est initialise' a` zero, alors que la doc
%HSAIL dit qu'on peut pas initialiser les group).  Le commentaire dit le
%contraire: par ex. il dit que les atomic stores sont sur global memory alors
%que dans le programme ils sont sur group (sur Y).}
\end{itemize} }

\section{Scopes}

Our \prog{herd} tool handles scopes by the means of various objects: scope
tags, scope trees, scope instances and sets of tagged events. These objects are
all defined by reading a prelude {\tt bell} file, supplied to \herd{} with the
\texttt{-bell} option. Appendix~\ref{bell} details the {\tt bell} file for HSA.

\subsection{Scope tags}
The document defines a hierarchy of five scope levels: system, agent,
work-group, wave and work-item here listed from wider to narrower.

Scope tags reflect these levels; work-item events are tagged {\tt wi}, and
work-group events {\tt wg}, the other tags being eponymous of the scope level: 
\begin{verbatim}
enum scopes = 'wi || 'wave || 'wg || 'agent || 'system
\end{verbatim}

\subsubsection{Concurrency hierarchy}

The functions {\tt narrower} and {\tt wider} implement the concurrency
hierarchy, making for example the scope level {\tt agent} narrower than {\tt
system}, and the scope level {\tt wave} wider than work-item {\tt wi}:
\begin{verbatim}
let narrower(s) = match s with
  || 'system -> 'agent
  || 'agent -> 'wg
  || 'wg -> 'wave
  || 'wave -> 'wi
end

let wider(s) = match s with
  || 'agent -> 'system
  || 'wg -> 'agent
  || 'wave -> 'wg
  || 'wi -> 'wave
end
\end{verbatim}

In these two functions we use the {\tt cat} construct {\tt match}; one can use
{\tt match} to match a tag value (here the argument {\tt s}) against a set of
\emph{patterns} (here the enum type of scope levels), and for each pattern
return a result.

\subsubsection{Sets of tagged events}

Scope tags can annotate events. For each tag {\tt 't}, our \prog{herd} tool
builds the set {\tt T} of all events that bear the tag {\tt 't}. For instance,
in Figure~\ref{isa2scopes}, we have
$\texttt{Wg} = \{ b \}$,
$\texttt{Agent} = \{ c \}$,
$\texttt{System} = \{ d,e \}$.
Sets of tagged events can be accessed from the scope tag
by a primitive, \verb+tag2set+.  For instance, in our \ltst{isa2} example, the
expression \verb+tag2set('system)+ will evaluate to the set of events
$\{d,e\}$.

\subsection{Scope trees}

Each test features a ``scope tree'' definition that specifies how the test
units are organised according to the scope hierarchy (defined by the fuctions
{\tt wider} and {\tt narrower}). Consider for instance the test \ltst{isa2}:

{\footnotesize
\begin{verbatim}
Bell isa2
{ 2:r1=-1; }
 P0                     | P1                         | P2                          ;
 w[] x 53               | r[atomic,scacq,agent] r0 y | r[atomic,scacq,system] r0 z ;
 w[atomic,screl,wg] y 1 | bne r0, 1, Exit1           | bne r0, 1, Exit2            ;
                        | w[atomic,screl,system] z 1 | r[] r1 x                    ;
                        | Exit1:                     | Exit2:                      ;
scopes: (agent (wg 0 1) (wg 2))
exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
\end{verbatim}
}
This test has three units, \myth{0}, \myth{1} and~\myth{2}.
According to the scope tree \verb+(agent (wg 0 1) (wg 2))+,
the first two units \myth{0} and \myth{1} are in the same work-group,
while the last unit~\myth{2} is in a different work-group.
Then, all units are in the same agent.
Our notation for scope trees is abbreviated by omitting
the scope tree levels that contain exactly one sub-instance.
Here, the complete scope tree specification is:
\begin{verbatim}
(system (agent (wg (wave (wi 0)) (wave (wi 1))) (wg (wave (wi 2)))))
\end{verbatim}
Observe that, in the complete scope tree above,
the system scope contains exactly one agent, each work-group contain
exactly one wave, etc.

\subsection{Scope instances}
Hence, at runtime, there will be two ``scope instances'' of the work-group
level. We model these scope instances in \cat{} as relations eponymous of the
corresponding scope levels. Thus a scope instance is an equivalence relation
that relates events whose units are in the same scope instance of the given
level.

\subsubsection{Scope instances}
Given a tag \texttt{'t}, \texttt{tag2scope('t)} returns the eponymous scope
instance relation {\tt t}.

As an example, Figure~\ref{isa2scopes} pictures the \wg{} scope instance (or
{\tt tag2scope('wg)}) for the \ltst{isa2} test.
We have omitted the reflexivity edges (\emph{i.e.} $a \wg a$, $b \wg b$ etc.) for clarity.
\begin{figure}[!h]
\caption{\label{isa2scopes} The \wg{} scope instance of the \ltst{isa2} test}
\begin{center}\moveback\fmt{isa2+scopes}\end{center}
\end{figure}

We could also have pictured the \agent{} scope instance. We refrain from doing
so, as there is a single agent scope instance that contains all units.  Thus,
the \agent{} scope instance in this case is the total relation over events, and
picturing it would clobber the diagram.

{\color{blue} Is that right? More precisely, does our notion of scope instance
match the intent?}

\subsubsection{Same instance}

Section 3.9 ```Scoped synchronization order'' of the HSA document states that
two operations may ''\emph{both specify (directly or indirectly through scope
inclusion) scope instance~$S$}''. We believe that this means for example that a
memory operation with tag agent also specifies work-group. More generally, the
scope tag~\textit{lvl} takes effect on all scopes at levels {\tt narrower}
than~\textit{lvl}. {\color{blue} Is that right?}

To handle this bit of the model, we define equivalence relations
\texttt{same-\textit{lvl}}, where \textit{lvl} is a scope tag. Two operations
are related by \texttt{same-\textit{lvl}} when
\begin{itemize}
\item the two operations are related by the scope instance \textit{lvl}, but
also 
\item they are tagged by scope~\textit{lvl} or {\tt wider}.
\end{itemize}

Hence, we first define a function \texttt{all-events} that takes
a (scope) tag as argument and returns all the events annotated by
this scope or {\tt wider}:

\begin{verbatim}
let rec all-events(tag) = match tag with
|| 'system -> tag2events(tag)
|| _ -> tag2events(tag) | all-events(wider(tag))
end
\end{verbatim}

Here we use {\tt let rec} because the function {\tt all-events} is
\emph{recursive} (see how {\tt all-events} is called within itself).

Now we can define the function~\texttt{same-instance} that takes a scope
tag~\texttt{'\textit{lvl}} as argument and returns the
relation~\texttt{same-\textit{lvl}}:
\begin{verbatim}
let same-instance(lvl) =
 let evts = all-events(lvl) in
 tag2scope(lvl) & (evts * evts)
\end{verbatim}
The function {\tt same-instance} simply computes the intersection of the scope
instance {\tt tag2scope(lvl)} and of the cartesian product {\tt (evts * evts)}
on events tagged with scope level~\textit{lvl} or {\tt wider}.

\begin{figure}[!h]
\caption{\label{isa2same}The \same{wg} and~\same{agent} relations of the \ltst{isa2} test.}
\begin{center}\moveback\fmt{isa2+instances}\end{center}
\end{figure}
Figure~\ref{isa2same} shows two {\tt same-\textit{lvl}} relations (once again
we omitted reflexivity edges for clarity; in particular $e \same{wg} e$ is
omitted).  Also note that we both have $c \same{agent} d$ and~$c \same{wg} d$.
This comes from scope inclusion: events $c$ and~$d$ are from the same
unit~\myth{1}.  Hence, they belong to the same agent and work-group scope
instances.  Moreover, given event scope annotations (\texttt{agent} and
\texttt{system} respectively) the events both act up to the agent level.

\subsubsection{A final question}

{\color{blue} Consider the following excerpt, in the assembly given in the HSA
documentation, where A and B are in different work groups:
\begin{verbatim}
group_u32 &X ;

A:
atomic_st_scar_wg_u32 [&X],1 ;

B:
atomic_st_scar_wg_u32 [&X],2 ;
\end{verbatim}

We wonder if we should consider that there is one variable $X$, or rather two,
one for each scope instance. Another way of seeing this question is to
determine whether the program is racy or not: with one variable $X$ it is racy,
otherwise it isn't.}

\section{Axioms}

\subsection{\label{coherence}Coherence}

For a given location~$L$, the coherence order $\cohl{L}$ is defined as a total
order on all loads and stores to location~$L$. The ``single Coherent Order''
$\coh$ is the union of all these orders for all locations.  In
appendix~\ref{coh} we describe how to generate the set of all possible $\coh$
orders in the \cat{} language.  For now, let us assume a variable
\texttt{allCoh} whose value is the set of all possible \coh{} orders.

The instruction \texttt{with $v$ from $S$} will, for each~$e$ in $S$, execute
the rest of the model in an extended environment that binds $v$ to~$e$. For
\coh{}, we write: \verb+with coh from allCoh+. This means that we bind the
variable {\tt coh} to a \coh{} order picked in the set {\tt allCoh}. 

\subsubsection{Consistency of {\tt coh} and {\tt po}}

We can then  check the consistency of $\coh$ and~$\po$:
\begin{verbatim}
call consistent(coh,po) as CohPoCons
\end{verbatim}
See appendix~\ref{procedure} for the definition of the consistency check as
a procedure.

\includegraphics[width=08cm]{allcoh}

\subsubsection{Value of a load}

The ``value of a load'' check states that: ``\emph{a load [\ldots] will always
observe the most recent store in the coherent order of location~$L$}''.

Given a read of location $L$, we find ``the most recent store in the coherent
order of location $L$'' using the relation \texttt{mincohWR}. This relation
is implemented in the \cat{} language as follows:
\begin{verbatim}
let cohWR = coh & (W * R)
let cohWW = coh & (W * W)
let mincohWR = cohWR \ (cohWW; cohWR)
\end{verbatim}
where \verb+W+ is the set of all writes, \verb+R+ the set of all reads,
\verb+W*R+ is the set of write-read pairs (which can also be viewed as a
relation that relates any write to all reads), \verb+W*W+ the set of
write-write pairs, ``\verb+&+'' is intersection, ``\verb+*+'' is cartesian
product and ``\verb+\+'' is (set or relation) difference. To implement ``value
of a load'', we check that $\rf$ equals \texttt{mincohWR}: \verb+call equals(rf,mincohWR) as LoadCons+

\includegraphics[width=10cm]{value-of-a-load}
\vspace*{-2mm}
 
See appendix~\ref{procedure} for the definition of the procedure {\tt equals}.

\pagebreak

\subsubsection{\label{rmw}Read-modify-writes}

\begin{verbatim}
let cohRW = coh & (R * W)
empty rmw & (cohRW;cohWW) as RmwCons
\end{verbatim}
A RMW operation corresponds to two events, a read and a write, which are
related by a pre-defined \texttt{rmw} relation.

We state the atomicity of RMW's as follows:
\begin{verbatim}
empty rmw & (cohRW;cohWW) as RmwCons
\end{verbatim}

\includegraphics[width=10cm]{rmwcons}

\subsection{Local and global dependence orders}

\subsubsection{Local dependence order}

The document defines the ``local dependence order'' $\ldo$ informally as the
union of data, address and control dependencies (Sec 3.8).

Our \prog{herd} tool provides pre-defined relations for the three kinds of
dependency relations:
Hence we write
\begin{verbatim}
let ldo = data | addr | ctrl
\end{verbatim}

Note that in the absence of a concrete ISA this essentially amounts to having
\emph{dependency fences}.

{\color{blue} We note that no provision is made to restrict control
dependencies: for example on Power or ARM a branch between two reads does not
yield a control dependency (one needs to place an {\tt isync} (resp. {\tt isb})
fence after the branch on Power (resp. on ARM) to create a dependency from read
to read via a branch).  Is that intentional? Should we restrict {\tt ctrl}?}

\subsubsection{Global dependence order}

The document then defines the ``global dependence order'' as
the irreflexive transitive closure of \ldo{} union \coh{},
which we write
\begin{verbatim}
let gdo = (ldo|coh)+
\end{verbatim}

The document then states
``\emph{By rule, there cannot be a cycle in in \gdo{}}'',
which we interpret as a requirement: \gdo{} must be acyclic:

\begin{verbatim}
acyclic gdo as GdoCons
\end{verbatim}

\subsubsection{No thin air}

It seems to us that requiring {\tt gdo} acyclic aims at forbidding \emph{out of
thin air} values, as illustrated by the typical example ``\ltst{lb+ldos}'':
\begin{center}
\moveback\fmt{lb+ldos}
\end{center}

{\color{blue} We have several questions on that topic:
\begin{itemize}
\item Is that right, that the intent is to forbid out of thin air values?
\item How about placing fences in between the read-write pairs on each
thread, should that forbid the LB behaviour above?
\item How about having one step of {\tt ldo} then an internal {\tt coh} step on
	each thread, should that forbid the LB behaviour? And the other way
	around? One step of internal {\tt coh} then one step of {\tt ldo} on
	each thread, should that forbid the LB behaviour?
\end{itemize}}

{\color{blue} Let us investigate each of these items in more details:

\paragraph{Fences}

Consider this fenced variant of the LB test:
\begin{verbatim}
Bell LB+fences 
{
x = 0;
y = 0;
}
 P0                              | P1                              ;
 r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
 f[...]                          | f[...]                          ;  
 w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;

scopes:
(system (agent (wg (wave (wi P0)) (wave (wi P1)))))

regions: x:global, y:global

~exists (0:r1=1 /\ 1:r2=1)
\end{verbatim}

Are there any tags we can put on the fences that would forbid the weak
behaviour of this test (viz the case where both registers hold the value $1$ in
the end)? We're wondering about both memory order and scope tags. Also, under
what scope tree or scope instances?

More generally, should {\tt ldo} include something along the lines of:
\begin{verbatim}
(po & (_ * (F & Tag));po) & same-instance('tag)
\end{verbatim}

\paragraph{Interaction of {\tt ldo} and {\tt coh}}


More generally, should {\tt ldo} include something along the lines of:
\begin{verbatim}
po-loc 
\end{verbatim}

alternatively: 
\begin{verbatim}
coh & ~ext
\end{verbatim}

For example, consider this variant of the LB test (where {\tt dep} stands for
``dependency'', and could be any of {\tt addr, data} or {\tt ctrl}):

\pagebreak

\begin{verbatim}
Bell LB+dep-cohWW+dep
{
x = 0;
y = 0;
}
 P0                              | P1                              ;
 r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
 f[dep]                          | f[dep]                          ;  
 w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
 w[ordinary,rlx,wi,single] y 2   |                                 ;
scopes:
(system (agent (wg (wave (wi P0)) (wave (wi P1)))))

regions: x:global, y:global

~exists (0:r1=1 /\ 1:r2=2)
\end{verbatim}

Should the weak behaviour of LB be forbidden in this case? Namely the one where
{\tt r2} on {\tt P1} holds $2$ and {\tt r1} on {\tt P0} holds $1$ at the end.

Or this variant:
\begin{verbatim}
Bell LB+dep-cohRW+dep
{
x = 0;
y = 0;
}
 P0                              | P1                              ;
 r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
 f[dep]                          | f[dep]                          ;  
 r[ordinary,rlx,wi,single] r3 y  | w[ordinary,rlx,wi,single] x 1   ;
 w[ordinary,rlx,wi,single] y 1   |                                 ;
scopes:
(system (agent (wg (wave (wi P0)) (wave (wi P1)))))

regions: x:global, y:global

~exists (0:r1=1 /\ 1:r2=1)
\end{verbatim}

Should the weak behaviour of LB be forbidden in this case? Namely the one where
{\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.

\pagebreak

Or this variant:
\begin{verbatim}
Bell LB+dep-cohRW-cohWW+dep
{
x = 0;
y = 0;
}
 P0                              | P1                              ;
 r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
 f[dep]                          | f[dep]                          ;  
 r[ordinary,rlx,wi,single] r3 y  | w[ordinary,rlx,wi,single] x 1   ;
 w[ordinary,rlx,wi,single] y 1   |                                 ;
 w[ordinary,rlx,wi,single] y 2   |                                 ;
scopes:
(system (agent (wg (wave (wi P0)) (wave (wi P1)))))

regions: x:global, y:global

~exists (0:r1=1 /\ 1:r2=2)
\end{verbatim}

Should the weak behaviour of LB be forbidden in this case? Namely the one where
{\tt r2} on {\tt P1} holds $2$ and {\tt r1} on {\tt P0} holds $1$ at the end.

Or this variant:
\begin{verbatim}
Bell LB+dep-cohRR-dep+dep
{
x = 0;
y = 0;
}
 P0                              | P1                              ;
 r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
 f[dep]                          | f[dep]                          ;  
 r[ordinary,rlx,wi,single] r3 z  | w[ordinary,rlx,wi,single] x 1   ;
 r[ordinary,rlx,wi,single] r4 z  |                                 ;
 f[dep]                          |                                 ;  
 w[ordinary,rlx,wi,single] y 1   |                                 ;
scopes:
(system (agent (wg (wave (wi P0)) (wave (wi P1)))))

regions: x:global, y:global

~exists (0:r1=1 /\ 1:r2=1)
\end{verbatim}

Should the weak behaviour of LB be forbidden in this case? Namely the one where
{\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.

\pagebreak

Or this variant:
\begin{verbatim}
Bell LB+cohRR-dep+dep
{
x = 0;
y = 0;
}
 P0                              | P1                              ;
 r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
 r[ordinary,rlx,wi,single] r3 x  |                                 ;
 f[dep]                          | f[dep]                          ;  
 w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
scopes:
(system (agent (wg (wave (wi P0)) (wave (wi P1)))))

regions: x:global, y:global

~exists (0:r1=1 /\ 1:r2=1)
\end{verbatim}

Should the weak behaviour of LB be forbidden in this case? Namely the one where
{\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.

Or this variant:
\begin{verbatim}
Bell LB+cohRW-cohWR-dep+dep
{
x = 0;
y = 0;
}
 P0                              | P1                              ;
 r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
 w[ordinary,rlx,wi,single] x 1   |                                 ; 
 r[ordinary,rlx,wi,single] r3 x  |                                 ;
 f[dep]                          | f[dep]                          ;  
 w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
scopes:
(system (agent (wg (wave (wi P0)) (wave (wi P1)))))

regions: x:global, y:global

~exists (0:r1=1 /\ 1:r2=1)
\end{verbatim}

Should the weak behaviour of LB be forbidden in this case? Namely the one where
{\tt r2} on {\tt P1} holds $1$ and {\tt r1} on {\tt P0} holds $1$ at the end.}

\pagebreak

\subsubsection{Write-to-read causality}

We observe that the definition of {\tt gdo} as is forbids \ltst{wrc+ldos}:
\begin{center}
\moveback\fmt{wrc+ldos}
\end{center}

{\color{blue} Is that intentional? If the intent of requiring {\tt gdo} acyclic
is only to forbid out of thin air values, then {\tt gdo} could be simplified,
and only include a fragment of {\tt coh}. More precisely {\tt gdo} could
include {\tt rfe}, viz the \rf{} relation when source and target belong to
different units (below the pre-defined relation {\tt ext} gathers pairs of
events from different units):
\begin{verbatim} 
let rfe = rf & ext
let gdo = (ldo | rfe)+
acyclic gdo as GdoCons
\end{verbatim}

Or even, omitting the transitive closure: {\tt let gdo = ldo | rfe}. Indeed
taking the transitive closure doesn't change anything when requiring {\tt gdo}
to be acyclic, and {\tt gdo} is never used later in the model.

Note (see the event tags in the figure above) that all memory accesses in test
\ltst{wrc+ldos} are atomic relaxed.  Furthermore, the pictured execution
validates the coherence constraints (our section~\ref{coherence}) and, provided
the three units~\myth{0}, \myth{1} and~\myth{2} are in the same work-group, the
execution is not racy.  Hence, there are no further constraints on this
execution and the test being allowed or forbidden depends exclusively on the
definition of \texttt{gdo}.  More precisely with \texttt{gdo} being
\verb!(ldo|coh)+! the test is forbidden; with \texttt{gdo} being
\verb!(ldo|rfe)+! the test is allowed.}

Assuming this is the intent, let us revisit similar questions to the LB ones on
the WRC test case. 

\pagebreak

{\color{blue} Consider the following variant of WRC:
{\footnotesize
\begin{verbatim}
Bell wrc+fence+dep
{
2:r1=-1;
}
P0                          | P1                           | P2                           ;
w[atomic,rlx,wg,single] x 1 | r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
                            | f[...]                       | bne r0, 1, Exit2             ;
                            | w[atomic,rlx,wg,single] y 1  | r[atomic,rlx,wg,single] r1 x ;
                            |                              | Exit2:                       ;
exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
\end{verbatim}
}

Are there any tags we can put on the fence on {\tt P1} that would forbid the
weak behaviour of this test (viz the case where on {\tt P1} {\tt r0} holds $1$,
i.e. {\tt P1} has read from {\tt P0}, and on {\tt P2} {\tt r0} holds $1$, i.e.
{\tt P2} has read from {\tt P1}, and finally on {\tt P2} {\tt r1} holds $0$,
meaning {\tt P2} has read $x$ from the initial state)? We're wondering about
both memory order and scope tags. Also, under what scope tree or scope
instances?

And what about this variant:
{\footnotesize
\begin{verbatim}
Bell wrc+dep+fence
{
2:r1=-1;
}
 P0                          | P1                           | P2                           ;
 w[atomic,rlx,wg,single] x 1 | r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
                             | bne r0, 1, Exit1             | f[...]                       ;
                             | w[atomic,rlx,wg,single] y 1  | r[atomic,rlx,wg,single] r1 x ;
                             | Exit1:                       |                              ;
exists
(1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
\end{verbatim}
}

Are there any tags we can put on the fence on {\tt P2} that would forbid the
weak behaviour of this test (viz the case where on {\tt P1} {\tt r0} holds $1$,
i.e. {\tt P1} has read from {\tt P0}, and on {\tt P2} {\tt r0} holds $1$, i.e.
{\tt P2} has read from {\tt P1}, and finally on {\tt P2} {\tt r1} holds $0$,
meaning {\tt P2} has read $x$ from the initial state)? We're wondering about
both memory order and scope tags. Also, under what scope tree or scope
instances?}

\subsubsection{Distributed S shape}

We observe that the definition of {\tt gdo} as is forbids
\ltst{distributed-S+deps}:
{\footnotesize
\begin{verbatim}
Bell distributed-S+deps
{
2:r1=-1;
}
P0                          | P1                           | P2                           ;
w[atomic,rlx,wg,single] x 2 | r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
                            | f[dep]                       | f[dep]                       ;
                            | w[atomic,rlx,wg,single] y 1  | w[atomic,rlx,wg,single] x 1  ;
exists (1:r0=2 /\ 2:r0=1 /\ x=2)
\end{verbatim}
}

{\color{blue} Is that intentional? If the intent of requiring {\tt gdo} acyclic
is only to forbid out of thin air values, then {\tt gdo} could be simplified,
along the lines of what we write above.}

\subsection{Heterogeneous happens-before}

\subsubsection{Scoped synchronisation order \label{sso}}

We can now define scoped synchronisation orders, which we believe essentially
formalise release-acquire synchronisation, with scope restrictions. Recall the
{\tt cat} definitions of the sets {\tt Release}, {\tt Acquire} and {\tt
Synchronizing}:
\begin{verbatim}
let Release = Screl | Scar
let Acquire = Scacq | Scar
let Synchronizing = Acquire | Release
\end{verbatim}

Note that the \texttt{screl}, \texttt{scacq} and~\texttt{scar} tags apply to
atomic operations and to fences only. As a consequence, the above sets regroup
atomic operations and fences only.

To build the scoped synchronisation order, we follow Sec. 3.9, up to a few
minor changes:
\begin{verbatim}
let acq-rel =
  (((W | RMW) & Release) * ((R | RMW) & Acquire)) & (same-size & coh)
| ((F & Release) * Acquire) &
  ((po & (_ * (W | RMW))); (same-size & coh); (po? & ((R | RMW) * _)))
| (Release * (F & Acquire)) &
  ((po? & (_ * (W | RMW))); (same-size & coh); (po & ((R | RMW) * _)))

let sso(lvl) = same-instance(lvl) & acq-rel
\end{verbatim}

{\color{blue} Note that we do not impose for the intermediate $A$ and~$B$
operations (the ones such that $A \coh B$) to be atomic accesses in the last
two cases.  Although this is a race, we did not find this to be specified in
the HSA document. Is that intentional?}

The definition of \texttt{acq-rel} gathers the three top-level items of the
description of the HSA document.  It uses set and relation constructs
intensively, most of which have already been introduced, except the ``optional
step'' operator~\texttt{$e$?} that yields, \texttt{$e$|id} (\emph{i.e.} $e$
union the identity relation), and the universe set ``\verb+_+'' that contains
all events (even fence events).

Our (minor) changes are:
\begin{itemize}
\item we do not specify the accesses to be synchronising or atomic, as our
\texttt{Acquire} and \texttt{Release} sets contain synchronising
operations~only;
%\item we make no specific provision for
%RMW operations as they are represented by a read event (in~\verb+R+)
%and a write event (in \verb+W+) (see our section~\ref{rmw});
\item we made the definition a bit more symmetric (and redundant) by having the
third item produce fence-to-fence order, as the second item does;

\item we have factored out the condition ``\emph{$X$ and~$Y$ both specify the
same instance~$S$}'' (implemented by the call to ``\verb+same-instance(s)+'').
\end{itemize}

\pagebreak

\paragraph{An example: ISA2}

As an illustration, let us examine the test~\ltst{isa2}:
{\footnotesize
\begin{verbatim}
Bell isa2
{
2:r1=-1;
}
 P0                            | P1                                 | P2                                 ;
 w[] x 53                      | r[atomic,scacq,agent,single] r0 y  | r[atomic,scacq,system,single] r0 z ;
 w[atomic,screl,wg,single] y 1 | w[atomic,screl,system,single] z 1  | r[] r1 x                           ;
scopes: (agent (wg 0 1) (wg 2))
exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
\end{verbatim}
}

Below in Figure~\ref{isa2coh} we consider a particular execution candidate of
the test~\ltst{isa2}, viz a certain~\rf{} relation and a certain~\coh{}
relation:
\begin{figure}[!h]
\caption{\label{isa2coh}An execution candidate of the test~\ltst{isa2}}
\begin{center}\fmt{isa2+coh}\end{center}
\end{figure}

{\color{blue} Does this picture match the intent?}

More precisely,
\begin{itemize}
\item given the condition \verb+exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)+ of the
test, we select an execution where the read from~\texttt{y} by the
unit~\myth{1} reads the value \texttt{1}, which is stored to~\texttt{y} by the
unit~\myth{0}.  Hence, we select an execution where $b \rf c$.  Similarily we
select $d \rf e$.  Finally we consider that the event~$f$ reads the initial
value of~\texttt{x}, which is pictured by a red~\rf{} arrow from the
``initial'' event  (top of figure) to event~$f$.

\item We select some \coh{} relation that passes the coherence checks of
section~\ref{coherence}.  For clarity of the picture, we do not show the
complete \coh{} relation but a sub-relation (essentially edges that can be
deduced by transitivity are omitted).  The significant pairs of this \coh{}
relation are $b \coh c$, $d \coh e$ (which are the same as inter-unit \rf{}
pairs), and $f \coh a$ which originates from event~$f$ reading the initial
value of~\texttt{x}, which implies that the event $f$  is \coh-before all
writes to~\texttt{x} performed by all the units of the test.
\end{itemize}

\paragraph{An illustration of sso on ISA2}

Now that we have defined \coh{}, we can compute scope synchronisation orders.
Figure~\ref{isa2sso} shows the scope synchronisation orders for scopes agent
and work-group, for the test ISA2.
\begin{figure}[!h]
\caption{\label{isa2sso}Scope synchronisation orders for scopes agent (\textsf{sso-agent}) and work-group (\textsf{sso-wg}).}
\begin{center}\moveback\fmt{isa2+sso}\end{center}
\end{figure}

{\color{blue} Does this picture match the intent?}

Observe that the pair~$b \sso{wg} c$ results from the first case of the
definition of \verb+acq-rel+, namely 
\verb+((W & Release) * (R & Acquire)) & coh+, 
as $b$ is a write release (tag~\texttt{screl} in Figure~\ref{isa2sso}) and $c$
is a read acquire (tag~\texttt{scacq}).

Furthermore, we have $b \coh c$ (Figure~\ref{isa2coh}), thus the pair~$(b,c)$
is part of \texttt{acq-rel}.  Finally, events $b$ and $c$ specify the same
scope instance of level work-group, as illustrated by the pair $b \same{wg} c$
depicted in Figure~\ref{isa2same}.

Hence,  we have $b \sso{wg} c$, since we defined $\sso{wg}$ as the intersection
of the relations \texttt{acq-rel} and $\same{wg}$ (implemented as
\texttt{same-instance('wg)}).

\subsubsection{Heterogeneous happens-before}

Following the HSA~document, we define the HSA-happens-before order~\hhb{} as
the transitive closure of the union of the program order and of the union of
scope synchronisation order for all scopes:
\begin{verbatim}
let union-scopes f = fold (fun (s,y) -> f s | y) (scopes,0)

let hhb = (po | union-scopes sso)+
\end{verbatim}

The function \texttt{union-scopes} takes a function {\tt f} as argument.  This
function {\tt f} should go from scope tags to relations, typically just like
\texttt{sso}.

The function \texttt{union-scopes} returns the union of the
\texttt{$f(\textit{lvl})$} for all scope tags.  It refers to the
\texttt{scopes} tag set, which is implicitly defined by the 
\verb+enum scopes = +\ldots{} definition, and to the \verb+fold+ (over sets)
function, defined in appendix~\ref{coh}.

In the case of the test~\ltst{isa2} we get the \hhb{} relation pictured
in figure~\ref{isa2hhb}.
\begin{figure}
\caption{\label{isa2hhb} The HSA happens-before relation for test~\ltst{isa2}}
\begin{center}\fmt{isa2+hhb}\end{center}
\end{figure}
Edges that result from the transitivity of~\hhb{} are omitted. In particular
the pair $a \hhb f$ is omitted. {\color{blue} Does this picture match the
intent?}

Now, the HSA document defines three validity conditions on~\hhb.  The \hhb{}
relation must be acyclic (equivalently irreflexive, as \hhb{} is transitive),
consistent with \coh{}, and consistent with sequentially consistent orders
(which we shall see in the next section).
We express the first two conditions as follows:
\begin{verbatim}
irreflexive hhb as HhbCons
call consistent (hhb,coh) as HhbCohCons
\end{verbatim}
Note that Figure~\ref{isa2hhb} illustrates a case of inconsistency of \hhb{}
and~\coh{}: $a \hhb f \coh a$. And indeed, our \ltst{isa2} test is
similar to the test ``Race-free transitive synchronisation through multiple
scopes'' of the HSA document (replacing \texttt{while} loops by \texttt{if}
constructs). It should thus be forbidden.

\subsection{Sequentially consistent synchronisation order \label{sc-orders}}
Sec. 3.10 of the HSA document states: ``\emph{there is a total (apparent) order
of all synchronising operations with release, acquire, or acquire-release
semantics in a single scope instance}''.  Given a scope instance~$S$, we write
$\SCS{S}$ for this total order, and $\SCLVL{lvl}$ for the union of  $\SCS{S}$
orders for all scope instances at level~\textit{lvl}. We also abbreviate
sequentially consistent synchronisation order as ``SC order''.

Recall that \prog{herd} builds pre-defined sets of tagged events; for example
{\tt Screl} is the set of events bearing the tag {\tt screl}. From these sets,
we build a few relevant sets:
\begin{verbatim}
let Release = Screl | Scar
let Acquire = Scacq | Scar
let Synchronizing = Acquire | Release
\end{verbatim}

The \cat{} primitive \texttt{classes} takes an equivalence relation as argument
and returns its equivalence classes as a set of sets of events. Hence we can
compute the set of all scope instances~$S$ for a given level~\textit{lvl}
as follows:
%\marginpar{Luc for Jade, all
%our models use \texttt{same-instance} in place of \texttt{tag2scope}\ldots}

\begin{verbatim}
let sync-instances(lvl) =
  classes ((Synchronizing * Synchronizing) & tag2scope(lvl))
\end{verbatim}
The function~\verb+sync-instance+ takes a scope tag as argument and returns
a set of sets of events, each set of events being a scope instance.

{\color{blue} Here we could also use {\tt same-instance(lvl)}, which also takes
into account the scope tags on the synchronisation operations ordered by {\tt
sync-instances(lvl)}. What is the intent here? Note that choosing {\tt
tag2scope(lvl)} makes checking the consistency of SC orders wrt one another
somewhat superfluous, because the domain and range of each SC order are
included in the domain and range of the wider SC orders, whereas with {\tt
same-instance} it does not.}

Then, the HSA  document clearly states that the total order $\SC{$S$}$
extends \po{}: ``\emph{Given synchronisation operations $X$ and~$Y$, if $X \po Y$ and $X$ and~$Y$ specify the same scope instance~$S$ (directly or indirectly
through inclusivity), then $X \SC{$S$} Y$}''.
However it is unclear if this applies to any pair of synchronising operations
that belong to~$S$, or only to those whose scope annotations take effect
at the level of~$S$. 
%\fixme{jade: je comprends pas la difference}
%Nevertheless, as $\SC{$S$}$ is total and later required to be consistent
%with $\po$ it does not matter much. 
We choose the first, more simple, interpretation. Hence given a scope
instance~$S$, we compute the set of $\po$ linearisation on~$S$ as follows:
\begin{verbatim}
let preSC = po
let makeSCinstance(S) = linearisations(S,preSC)
\end{verbatim}
The \texttt{linearisation($S$,$r$)} primitive that computes all topological sorts of the graph $(S \times r)$ is introduced in appendix~\ref{coh}.
Finally, we compute the set of all possible $\SCLVL{lvl}$ relations as:
\begin{verbatim}
let makeSCscope(lvl) = cross (map makeSCinstance (sync-instances(lvl)))
\end{verbatim}
The function~\texttt{map} is map over sets. In the code above it serves
to compute the set of the sets of all possible $\SCS{S}$ orders
for all scope instances~$S$ at level~\textit{lvl}.
The function~\texttt{cross} takes a set of sets $\{S_1,S_2,\ldots,S_n\}$ as
argument and returns its \emph{cross product}, i.e. the set of all sets built
by picking one element in each~$S_i$. Those two functions are introduced in
appendix~\ref{coh}.

{\color{blue} To help us settle these questions on SC orders, it'd be helpful
to know whether two synchronising operations by the same unit, bearing the
annotation work-group should be ordered by the SC order of their scope instance
of level agent.}

\includegraphics[width=10cm]{cross}

\pagebreak

Finally, we iterate over all possible choices of $\SCLVL{lvl}$ for the five
HSA scope levels as follows\footnote{A different, more generic,
coding as a loop over the set of scope tags \texttt{scopes} is possible.
We found it to be a bit obfuscated and refrain from presenting it.}: 
%\fixme{jade@Luc: pour la presentation dans ce document, est-ce qu'on pourrait
%mettre tout ca dans une procedure, avec un forall?}
\begin{verbatim}
with SWI from makeSCscope('wi)
call consistent(SWI,coh) as ScCohCons
call consistent(SWI,hhb) as ScHhbCons
with SWAVE from makeSCscope('wave)
call consistent(SWAVE,coh) as ScCohCons
call consistent(SWAVE,hhb) as ScHhbCons
with SWG from makeSCscope('wg)
call consistent(SWG,coh) as ScCohCons
call consistent(SWG,hhb) as ScHhbCons
with SAGENT from makeSCscope('agent)
call consistent(SAGENT,coh) as ScCohCons
call consistent(SAGENT,hhb) as ScHhbCons
with SSYSTEM from makeSCscope('system)
call consistent(SSYSTEM,coh) as ScCohCons
call consistent(SSYSTEM,hhb) as ScHhbCons
\end{verbatim}
Notice that we also check the consistency of SC orders with \coh{} and \hhb{},
as required, but not with~\po{}.
Indeed, by construction the ``order'' \SCLVL{lvl} includes~\po{} and
the two relation are thus consistent.
It remains to check that the SC orders are pairwise consistent:
%\marginpar{Luc to Jade, unclear whether omitting the \texttt{ScSc}
%checks will impact valid candidates or not.}
%\fixme{jade@Luc: pour la presentation dans ce document, est-ce qu'on pourrait
%mettre tout ca dans une procedure, avec un forall?}
\begin{verbatim}
call consistent(SWI,SWAVE) as ScSc
call consistent(SWI,SWG) as ScSc
call consistent(SWI,SAGENT) as ScSc
call consistent(SWI,SSYSTEM) as ScSc
call consistent(SWAVE,SWG) as ScSc
call consistent(SWAVE,SAGENT) as ScSc
call consistent(SWAVE,SSYSTEM) as ScSc
call consistent(SWG,SAGENT) as ScSc
call consistent(SWG,SSYSTEM) as ScSc
call consistent(SAGENT,SSYSTEM) as ScSc
\end{verbatim}

\pagebreak

\paragraph{An example: SB}

As an example, we consider the following test~\ltst{sb}:
\verbatiminput{img/sb.litmus}
The final proposition \verb+(0:r0 = 0 /\ 1:r0 = 0)+ correspond
to the \rf{} and \coh{} relations depicted in Figure~\ref{sbcoh}.
\begin{figure}[!h]
\caption{\label{sbcoh}The non-SC execution of test~\ltst{sb}}
\vspace*{-2mm}
\begin{center}\moveback\fmt{sb}\end{center}
\vspace*{-8mm}
\end{figure}
The execution is not sequentially consistent, since there is a cycle in $\po
\cup \coh$. As a result there is no total order that would be consistent with
$\po$ and $\coh$.

The scope tree specification of the test states that the two units of the test
are in the same work group. As a result, all events (which are synchronising
and specify scope work-group) live in the same work-group scope instance.
There is no SC order at the  work-group level. Thus figure~\ref{sbwg} shows a
contradiction between the workgroup SC order SWG and \coh{}.
\begin{figure}[!h]
\caption{\label{sbwg}Contradiction of the work-group SC order and coh}
\vspace*{-2mm}
\begin{center}\moveback\fmt{sb+wg}\end{center}
\vspace*{-2mm}
\end{figure}
One may observe that the pictured $\SC{wg}$ order contradicts \coh{} on
the pair $(a,d)$.

By contrast, the events of each unit can be ordered independently in each
work-item instance, as show in Figure~\ref{sbwi}.  Indeed the SWI order is
consistent with \po{} (in fact is equal to) and also with \coh{} restricted to
each scope instance, which happen to be empty.
\begin{figure}[!h]
\vspace*{-2mm}
\caption{\label{sbwi}A successful ordering of the two work-item scope instances}
\begin{center}\moveback\fmt{sb+wi}\end{center}
\vspace*{-2mm}
\end{figure}

\pagebreak

\section{Races}
The HSA document has two definition of conflicts: ordinary and special.
Ordinary conflicts are defined as follows:
``\emph{Two operations $X$ and~$Y$ conflict, iff they access one or
more common byte locations, at least one is a write, and at least one is
an ordinary data operation}''.
Having noticed that ``conflicts'' form a symmetric relation, we paraphrase
the definition:
\begin{verbatim}
let at-least-one a = (a * _) | (_ * a)

let ordinary-conflicts = loc & at-least-one(W) & at-least-one(Ordinary)
\end{verbatim}
We use the pre-defined relation \verb+loc+ that relates accesses to the same
location, and two pre-defined sets of events: \verb+W+ the set of write
operations, and \verb+Ordinary+ the set of ordinary data operations.

\label{specialconflict}The HSA document defines special conflicts as follows:
\begin{quote}\em
Two special operations $X$ and~$Y$ conflict iff $X$ and $Y$ access
the same byte location and:
\begin{itemize}
\item[35.] $X$ and~$Y$ are different sizes (e.g., 32-bit vs. 64-bit), or
\item[36.] At least one is a write (or a read-modify-write),
and $\neg(\textit{Match}(\textit{SI}(X), \textit{SI}(Y))$.
\end{itemize}
\end{quote}
Condition~36 refers to a (negated) \textit{Match} predicate and to
a~\textit{SI} function.  Both are defined in the ``Scope instances'' section of
the HSA document.

The function~\textit{SI} returns the set of scope instances specified by an
operation, and the \textit{Match} predicate tests the non-emptiness of the
intersection of these scope instances. In Section~\ref{sso} we have defined the
relation~\texttt{same-instance('\textit{lvl})} that relates events that specify
a common scope instance at level~\textit{lvl}. Hence, we
represent~\textit{Match} by the relation~\verb+matches+ that relates events
specifying a common scope instance at some level.  In effect, we quantify over
scope levels rather than on pairs of operations and  define \verb+matches+ as
the union of \texttt{same-instance('\textit{lvl})} for all scope levels. In
\cat{} we write: \begin{verbatim} let matches = union-scopes same-instance

let special-conflicts =
  (loc & (~same-size | Atomic * Atomic) & at-least-one(W)) \ matches
\end{verbatim}
The function~\verb+union-scopes+ that returns the union of
the application of a function on all scope tags is defined
in our Sec.~\ref{sso}. 

The definition of HSA conflicts lacks an additional condition:
accesses have to be by different units, which we consider in
the definition of conflicts below, by the means of the pre-defined~\verb+ext+
relation that relates operations by different units:
\begin{verbatim}
let conflicts = ((ordinary-conflicts|special-conflicts) & ext) \ at-least-one(IW)
\end{verbatim}
We have also added that initial writes (pre-defined set~\verb+IW+)
do not contribute to conflicts.
%As a matter of fact \herd{} considers the initial value of a location to come
%from an explicit initial write operation, for the $\rf$ relation to be defined
%on all read operations.

We then define races as conflicts that are not ordered by HSA happens-before,
in either direction (which we believe to be another omission of the HSA
document):
\begin{verbatim}
let hsa-race = conflicts \ (hhb | hhb^-1)
\end{verbatim}
We used the postfix~$r\texttt{\^{}-1}$ operator that evaluates to
the inverse of relation~$r$.

We inform the \prog{herd} tool about races using with the \texttt{flag}
construct, which apply to all checks.  The normal behaviour for a check is to
stop model execution when invalid.  By contrast, a failing flagged check does
not stop execution but instead ``flags'' it with an arbitrary flag (here
\verb+undefined+).

Flags are recorded and handed over to the \prog{herd} machinery at the end of
model execution --- hence for valid executions that passed all (unflagged)
checks.  The \prog{herd} tool can then decide that the simulated program is
undefined, as soon as one of the valid executions has been flagged as
\verb+undefined+.
\begin{verbatim}
flag ~empty hsa-race as undefined
\end{verbatim}
Observe that the execution is flagged when the \verb+hsa-race+ relation is
\emph{not} empty.

\pagebreak

\section{Examples}

%\subsection{From the documentation}
%
%\subsubsection{Example 1: IRIW}
%
%{\tiny
%\begin{verbatim}
%Bell HSA1 (*iriw*)
%{
%x = 0;
%y = 0;
%}
%P0                            | P1                            | P2                             | P3                             ;
%w[atomic,screl,wg,single] x 1 | w[atomic,screl,wg,single] y 1 | r[atomic,scacq,wg,single] r1 x | r[atomic,scacq,wg,single] r3 y ;
%                              |                               | r[atomic,scacq,wg,single] r2 y | r[atomic,scacq,wg,single] r4 x ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)) (wave (wi P2)) (wave (wi P3)))))
%
%regions: x:group, y:group
%
%~exists (2:r1=1 /\ 2:r2=0 /\ 3:r3=1 /\ 3:r4=0)
%\end{verbatim}
%}
%
%\subsubsection{Example: MP}
%
%{\footnotesize
%\begin{verbatim}
%Bell HSA2 (*mp*)
%{
%x = 0;
%y = 0;
%}
% P0                             | P1                             ;
% w[ordinary,rlx,wi,single] x 53 | r[atomic,scacq,wg,single] r1 y ;
% w[atomic,screl,wg,single] y 1  | r[ordinary,rlx,wi,single] r2 x ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:group, y:group
%
%exists(1:r1=1 /\ 1:r2=53)
%\end{verbatim}
%}
%
%\subsubsection{Example 3: ISA2}
%{\footnotesize
%\begin{verbatim}
%Bell HSA3 (*isa2*)
%{
%x = 0;
%y = 0;
%z = 0;
%}
% P0                                | P1                                 | P2                                 ;
% w[ordinary,rlx,wi,single] x 53    | r[atomic,scacq,system,single] r1 y | r[atomic,scacq,system,single] r2 z ;
% w[atomic,screl,system,single] y 1 | w[atomic,screl,system,single] z 1  | r[ordinary,rlx,wi,single] r3 x     ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)) (wave (wi P2)))))
%
%regions: x:global, y:global, z:global
%
%exists (1:r1=1 /\ 2:r2=1 /\ 2:r3=53)
%\end{verbatim}
%}
%
%\pagebreak
%
%\subsubsection{Example 4: ISA2}
%{\footnotesize
%\begin{verbatim}
%Bell HSA4 (*variant of isa2*)
%{
%x = 0;
%y = 0;
%z = 0;
%}
%P0                             | P1                                | P2                                   ;
%w[ordinary,rlx,wi,single] x 53 | r[atomic,scacq,wg,single] r1 y    | r[atomic,scacq,system,single] r3 z   ;
%                               | r[ordinary,rlx,wi,single] r2 x    |                                      ;
%w[atomic,screl,wg,single] y 1  | w[atomic,screl,system,single] z 1 | r[ordinary,rlx,wi,single] r4 x       ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1))) (wg (wave (wi P2)))))
%
%regions: x:group, y:group, z:group
%
%exists (1:r1=1 /\ 1:r2=53 /\ 2:r3=1 /\ 2:r4=53)
%\end{verbatim}
%}
%
%\subsubsection{Example  5: MP}
%{\footnotesize
%\begin{verbatim}
%Bell HSA5 (*mp*)
%{
%x = 0;
%y = 0;
%}
% P0                             | P1                                ;
% w[ordinary,rlx,wi,single] x 53 | r[atomic,scacq,agent,single] r1 y ;
% w[atomic,screl,wg,single] y 1  | r[ordinary,rlx,wi,single] r2, x   ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:global, y:global
%
%exists (1:r1=1 /\ 1:r2=53)
%\end{verbatim}
%}
%
%\subsubsection{Example 6: ISA2}
%{\footnotesize
%\begin{verbatim}
%Bell HSA6 (*variant of isa2*)
%{
%x = 0;
%y = 0;
%z = 0;
%}
% P0                             | P1                                | P2                                 ;
% w[ordinary,rlx,wi,single] x 53 | r[atomic,scacq,agent,single] r1 y | r[atomic,scacq,system,single] r3 z ;
%                                | r[ordinary,rlx,wi,single] r2 x    |                                    ;
% w[atomic,screl,wg,single] y 1  | w[atomic,screl,system,single] z 1 | r[ordinary,rlx,wi,single] r4 x     ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1))) (wg (wave (wi P2)))))
%
%regions: x:global, y:global, z:global
%
%exists (1:r1=1 /\ 1:r2=53 /\ 2:r3=1 /\ 2:r4=53)
%\end{verbatim}
%}
%
%\pagebreak
%
%\subsubsection{Example 7: MP}
%{\footnotesize
%\begin{verbatim}
%Bell HSA7 (*variant of mp*)
%{
%x = 0;
%y = 0;
%}
% P0                                   | P1                                 ;
% w[ordinary,rlx,wi,single] x 52       | r[atomic,scacq,system,single] r1 y ;
% w[ordinary,rlx,wi,single] x 53       |                                    ;
% w[atomic,screl,system,single] [y], 1 | r[ordinary,rlx,wi,single] r2 x     ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:global, y:global
%
%exists (1:r1=1 /\ 1:r2=53)
%\end{verbatim}
%}
%
%\subsubsection{Example 8: MP}
%{\footnotesize
%\begin{verbatim}
%Bell HSA8 (*variant of mp*)
%{
%x = 0;
%y = 0;
%}
% P0                             | P1                             ;
% w[ordinary,rlx,wi,single] x 53 | r[atomic,scacq,wg,single] r1 y ;
% w[atomic,screl,wg,single] y 1  | r[ordinary,rlx,wi,single] r2 x ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:global, y:group
%
%exists (1:r1=1 /\ 1:r2=53)
%\end{verbatim}
%}
%
%\subsubsection{Example 9: MP}
%{\footnotesize
%\begin{verbatim}
%Bell HSA9 (*variant of mp*)
%{
%x = 0;
%y = 0;
%}
% P0                             | P1                             ;
% w[ordinary,rlx,wi,single] x 53 | r[atomic,rlx,wg,single] r1 y   ;
% f[screl,wg]                    | f[scacq,wg]                    ;
% w[atomic,rlx,wg,single] y 1    | r[ordinary,rlx,wi,single] r2 x ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:group, y:group
%
%exists (1:r1=1 /\ 1:r2=53)
%\end{verbatim}
%}
%
%\pagebreak
%
%\subsubsection{Example 10: LB}
%{\footnotesize
%\begin{verbatim}
%Bell HSA10 (*lb*)
%{
%x = 0;
%y = 0;
%}
% P0                              | P1                              ;
% r[ordinary,rlx,wi,single] r1 x  | r[ordinary,rlx,wi,single] r2 y  ;
% w[ordinary,rlx,wi,single] y 1   | w[ordinary,rlx,wi,single] x 1   ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:global, y:global
%
%~exists (0:r1=1 /\ 1:r2=1)
%\end{verbatim}
%}
%
%\subsubsection{Example 11: LB}
%{\footnotesize
%\begin{verbatim}
%Bell HSA11 (*variant of lb*)
%{
%x = 0;
%y = 0;
%}
% P0                               | P1                               ;
% r[atomic,rlx,system,single] r1 x | r[atomic,rlx,system,single] r2 y ;
% w[atomic,rlx,system,single] y r1 | w[atomic,rlx,system,single] x r2 ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:global, y:global
%
%~exists (0:r1=1 /\ 1:r2=1)
%\end{verbatim}
%}
%
%\subsubsection{Example 12: SB}
%{\footnotesize
%\begin{verbatim}
%Bell HSA12 (*variant of sb*)
%{
%x = 0;
%y = 0;
%}
% P0                                | P1                               ;
% w[atomic,rlx,system,single] x 1   | w[atomic,rlx,system,single] y 1  ;
% r[atomic,rlx,system,single] r1 y  | r[atomic,rlx,system,single] r2 x ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:global, y:global
%
%exists(0:r1=0 /\ 1:r2=0)
%\end{verbatim}
%}
%
%\pagebreak
%
%\subsubsection{Example 13: write-read race}
%{\footnotesize
%\begin{verbatim}
%Bell HSA13 (*wr race*)
%{
%x = 0;
%}
% P0                             | P1                             ;
% w[ordinary,rlx,wi,single] x 1  | r[ordinary,rlx,wi,single] r1 x ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1)))))
%
%regions: x:global
%
%~exists(1:r1=0)
%\end{verbatim}
%}
%
%\subsubsection{Example 14: MP}
%{\footnotesize
%\begin{verbatim}
%Bell HSA14 (*variant of mp*)
%{
%x = 0;
%y = 0;
%}
% P0                            | P1                             ;
% w[ordinary,rlx,wi,single] x 1 | r[atomic,scacq,wg,single] r1 y ;
% w[atomic,screl,wg,single] y 1 | r[ordinary,rlx,wi,single] r2 x ;
%
%scopes:
%(system (agent (wg (wave (wi P0))) (wg (wave (wi P1)))))
%
%regions: x:global, y:global
%
%~exists (1:r1=1 /\ 1:r2=0)
%\end{verbatim}
%}
%
%\subsection{Extra}
%
%\subsubsection{Example 1: MP}
%
%{\tiny
%\begin{verbatim}
%Bell double-MP
%{
%x = 0;
%y = 0;
%z = 0;
%t = 0;
%}
% P0                             | P1                             | P2                             | P3                             ;
% w[ordinary,rlx,wi,single] x 53 | r[atomic,rlx,wg,single] r1 y   | w[ordinary,rlx,wi,single] z 53 | r[atomic,rlx,wg,single] r1 t   ;
% f[screl,wg]                    | f[scacq,wg]                    | f[screl,wg]                    | f[scacq,wg]                    ;
% w[atomic,rlx,wg,single] y 1    | r[ordinary,rlx,wi,single] r2 x | w[atomic,rlx,wg,single] t 1    | r[ordinary,rlx,wi,single] r2 z ;
%
%scopes:
%(system (agent (wg (wave (wi P0)) (wave (wi P1))) (wg (wave (wi P2)) (wave (wi P3)))))
%
%regions: x:group, y:group, z:group, t:group
%
%exists (1:r1=1 /\ 1:r2=53 /\ 3:r1=1 /\ 3:r2=53)
%\end{verbatim}
%}
%
%\pagebreak
%
%\subsubsection{Example 2: ISA2}
%
%{\footnotesize
%\begin{verbatim}
%Bell isa2+scopes
%{
%2:r1=-1;
%}
% P0                            | P1                                 | P2                                 ;
% w[] x 53                      | r[atomic,scacq,agent,single] r0 y  | r[atomic,scacq,system,single] r0 z ;
% w[atomic,screl,wg,single] y 1 | bne r0, 1, Exit1                   | bne r0, 1, Exit2                   ;
%                               | w[atomic,screl,system,single] z 1  | r[] r1 x                           ;
%                               | Exit1:                             | Exit2:                             ;
%scopes: (agent (wg 0 1) (wg 2))
%exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
%\end{verbatim}
%}
%
%\subsubsection{Example 3: LB}
%
%{\footnotesize
%\begin{verbatim}
%Bell lb+ldos
%{ }
% P0                           | P1                           ;
% r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
% bne r0, 1, Exit0             | bne r0, 1, Exit1             ;
% w[atomic,rlx,wg,single] y 1  | w[atomic,rlx,wg,single] x 1  ;
% Exit0:                       | Exit1:                       ;
%
%exists (0:r0=1 /\ 1:r0=1)
%\end{verbatim}
%}
%
%\subsubsection{Example 4: WRC}
%
%{\footnotesize
%\begin{verbatim}
%Bell wrc+ldos
%{
%2:r1=-1;
%}
% P0                          | P1                           | P2                           ;
% w[atomic,rlx,wg,single] x 1 | r[atomic,rlx,wg,single] r0 x | r[atomic,rlx,wg,single] r0 y ;
%                             | bne r0, 1, Exit1             | bne r0, 1, Exit2             ;
%                             | w[atomic,rlx,wg,single] y 1  | r[atomic,rlx,wg,single] r1 x ;
%                             | Exit1:                       | Exit2:                       ;
%exists (1:r0=1 /\ 2:r0=1 /\ 2:r1=0)
%\end{verbatim}
%}
\subsection{Tony1}

Tony proposed the following scenario:
\begin{quotation}
o   Assuming work-items release to agent scope when complete:

§  dispatch work items could do an atomic\_st\_screl\_agent to hidden variable
provided by packet processor

·         probably do a rmw to a single counter

§  packet processor does atomic\_ld\_acq\_agent on that variable so gets all data
written by dispatch

·         probably spin until counter to wait for whole dispatch to complete

§  packet processor would do memfence\_screl\_system if indicated by packet release fence

§  packet processor then does an atomic\_st\_rlx\_system to completion signal

§  host (or other) thread does atomic\_ld\_rlx\_system on completion signal

§  host (or other) thread can do a memfence\_scacq\_system if want to access generated data of dispatch

o   Does this model result in correct semantics given current memory model?
\end{quotation}

\begin{figure}[!h]
\setlength{\columnseprule}{.5pt}
\begin{multicols}{2}
\small
\verbatiminput{img/t1-alt.litmus}
\end{multicols}
\caption{A tentative packet processor fence scenario\label{ppf}}
\end{figure}
{\color{blue} We implement it as shown in Figure~\ref{ppf}.  First, does the
test match the intent? Our test implements the following scenario: \myth{0}
sends the value $1$ to \myth{1} via $x$ and to \myth{2} via $y$. Then both {\tt
P1} and {\tt P2} make calculations over $x$ and $y$ respectively, then
increment the counter $c$ atomically. When the counter has reached $2$,
\myth{0} accesses $x$ and $y$, and writes their updated values in the variables
{\tt d1} and {\tt d2}. After doing a release fence at system scope, \myth{0}
then sends a signal to \myth{3} via variable $s$; \myth{3} can then read {\tt
d1} and {\tt d2} after having done an acquire fence at system scope.

Moreover, to the question ``Does this model result in correct semantics given
current memory model'', our tool answers yes under the model that we present in
this document. More specifically
the SC and HSA model simulation produce the same outcomes.
The figures \ref{t100} and~\ref{t101}
depict the two SC executions where \myth{3} reads the value~$1$
from the flag variable~\texttt{s}.
The two executions only differ by the order in
which \myth{1} and \myth{2} increment the counter \texttt{c}.}

\begin{figure}
\caption{\label{t100}First execution of test~\ltst{Tony1}}
\begin{center}
%\moveback\fmt{t1-00}
\end{center}
\end{figure}

\begin{figure}
\caption{\label{t101}Second execution of test~\ltst{Tony1}}
\begin{center}
%\moveback\fmt{t1-01}
\end{center}
\end{figure}
\pagebreak

\subsection{Tony2}

Here we examine the other test proposed by Tony, from a question raised by
Hakan:

{\footnotesize
\verbatiminput{img/t2.litmus}
}

The test condition \verb+(2:r2=0 \/ 2:r3=0)+ groups three possible test
outcomes: one of the register being zero and not the other, and both register
being zero.
%We first depict a candidate execution where both
%register hold a final value of zero.
%\begin{figure}
%\caption{\label{t2fig}One execution of test~\ltst{Tony2}}
%\begin{center}\moveback\fmt{t2}\end{center}
%\end{figure}
The test performs two release-acquire synchronisations and thus
resembles the test~\ltst{isa2} (Figure~\ref{isa2coh}),
with the following differences:
\begin{itemize}
\item Two variables (\texttt{x} and~\texttt{y}) are synchronised
where~\ltst{isa2} synchronised only one variable.
\item There is a fence on~\myth{0}, but it does not seem to contribute to
synchronisation, because deleting the fence does not change test behaviour on
our model.
\item The scope tree is different.  More precisely the test~\ltst{Tony2} has
two work-groups scope instances $\{\myth{0}, \myth{2}\}$ and $\{\myth{1}\}$.
That is, \myth{0} and~\myth{2} synchronise through a unit (\myth{1}) that is
not a member of their work-group. Nevertheless, all units belong to the same
agent, and all synchronising actions (events $c$, $d$, $e$ and~$f$) bear the
\texttt{agent} scope tag.
\end{itemize}
As a result, there are happens-before edges from the writes $a$ (to~\texttt{x})
and~$b$ (to \texttt{y}) by \myth{0} to the reads of the same locations
by~\myth{2} (namely $g$ and~$h$). This suffices to forbid the specified
executions as there is a contradiction with~\coh{}.

For analysing how the test is forbidden in detail we relax some checks,
\emph{i.e.} we run the model without performing some checks.  First, by
relaxing the consistency of $\hhb$ and $\coh$ (i.e. calling \prog{herd} with
option \texttt{-skipchecks HhbCohCons}), we get one extra outcome: 
\verb+2:r2=1 /\ 2:r3=0+. The corresponding execution is shown in Figure~\ref{t2hhb}.

\begin{figure}[H]
\caption{\label{t2hhb}Relaxing the consistency of \hhb{} and \coh{}}
\begin{center}\moveback\fmt{t2+hhb}\end{center}
\end{figure}
In other words, the location~\texttt{x}, which is accessed by ordinary load and
store instructions is synchronised solely by the means of the consistency of
\hhb{} and \coh{}.  The figure clearly shows the inconsistency:
$a \hhb h \coh a$.
It is important to note that relaxing the consistency of
$\hhb$ and~$\coh$ does not change $\hhb$,
although \hhb{} is defined in terms of a sub-relation~of~$\coh$.

However, event~$g$ still cannot read zero, or, equivalently,
register \verb+2:r2+ cannot contain zero at the end of execution.
This means that the behaviour is
still rejected by other checks of the model.  As a matter of fact all accesses
to location~\texttt{y} are atomic and even synchronising. 

We thus examine sequentially consistent orders. We first assume that, for a
given scope instance~$S$ the SC order $\SCS$ orders all synchronising events
in~$S$, regardless of their scope annotations (i.e. we formalise {\tt
sync-instances} using {\tt tag2scope}, see discussion in Section
\ref{sc-orders}).  It is then enough to relax the consistency of SC orders and
\coh{} to observe a value of zero for the read~$g$.
\begin{figure}[htp]
\caption{\label{t2agent}Relaxing further the consistency of SC orders and of~\coh{}}
\begin{center}\moveback\fmt{t2+agent}\end{center}
\end{figure}
The contradiction is visible on Figure~\ref{t2agent}: $b \SC{agent} g \coh b$.
Note that $b \SC{agent} g$ stems from the consistency of SC orders and~\hhb.

We now consider an alternative definition of the domain of
SC orders:  $\SCLVL{lvl}$ now operates
on events that specify the scope~\textit{lvl} (or higher),
\emph{i.e.} we consider event scope annotations.
Such a restricted ``scope instance''
is depicted in figure~\ref{t2scope} as the equivalence relation
$\same{agent}$.
\begin{figure}[htp]
\caption{\label{t2scope}Restricted scope instance of level agent}
\begin{center}\moveback\fmt{t2+scope}\end{center}
\end{figure}
Note that neither~$b$ (write to~\texttt{y} by~\myth{0}) nor~$g$ (read
from~\texttt{y} by~\myth{2}) are part of the domain of~\SC{agent}. Thus
preventing $g$ from reading zero (\emph{i.e.} $g \coh b$) cannot come from a
contradiction between $\coh$ and~$\SC{agent}$.

The behaviour becomes allowed if we relax the consistency of SC orders and HSA
happens-before with $\coh$.  To understand how, note that the events $b$
and~$g$ are in the same work-group scope instance, and have the appropriate
\texttt{wg} scope tag.  Hence $b$ and~$g$ must be ordered by $\SC{wg}$, and, as
illustrated by Figure~\ref{t2wg}, the order must be $b \SC{wg} g$, which leads
to the sought contradiction with~\coh{}.

\begin{figure}[htp]
\caption{\label{t2wg}Relaxing further the consistency of SC orders and~\coh{}}
\vspace*{-5mm}
\begin{center}\moveback\fmt{t2+wg}\end{center}
\vspace*{-5mm}
\end{figure}
Note that $b \SC{wg} g$ stems from $b \hhb g$ by consistency of $\SC{wg}$
and~\hhb.

\subsection{Tony3}
The following test is our own.  It has the same scope tree as the
previous~\ltst{Tony2}, \emph{i.e.} there are two work-groups, $\{\myth{0},
\myth{2}\}$ and~$\{\myth{1}\}$; and one agent $\{\myth{0}, \myth{1},
\myth{2}\}$.  It has no significant~\hhb{} relation as there are no \rf{}~in
the execution of interest.

{\footnotesize
\verbatiminput{img/t3.litmus}
}

This test is forbidden by our models. This is rather comforting as the test is
not sequentially consistent ($\po \cup \coh$ has a cycle), and that
{\color{blue}using synchronising stores and loads should restore sequential
consistency (is that the intent?).}

However, restoring SC with synchronising accesses becomes a bit subtle in the
presence of several scope instances.

First, we examine our test under our first option for defining the domain of SC
orders, \emph{i.e.} we consider that a given SC order is defined over all the
synchronising events emitted by the units in a given scope instance (option
{\tt tag2scope} in the definition of {\tt sync-instance}, see
Section~\ref{sc-orders}). As for~\ltst{Tony2} our model rejects the test by the consistency of~\SC{agent}
(defined over all events here) and~\coh{}.  Figure~\ref{t3fst} shows such a
contradiction.

\begin{figure}[h!]
\caption{\label{t3fst}Relaxing the consistency of SC orders
and~\coh{} for the test~\ltst{Tony3}}
\vspace*{-5mm}
\begin{center}\moveback\fmt{t3+fst}\end{center}
\vspace*{-5mm}
\end{figure}

Then, we consider our second option for SC orders, \emph{i.e.} we consider that
a given SC order is defined over the events that specify a given scope instance
(option {\tt same-instance} in the definition of {\tt sync-instance}, see
Section~\ref{sc-orders}).

\begin{figure}[h!]
\caption{\label{t3}Relaxing the pairwise consistency of SC order for test~\ltst{Tony3}}
\vspace*{-5mm}
\begin{center}\moveback\fmt{t3}\end{center}
\vspace*{-5mm}
\end{figure}
Figure~\ref{t3} illustrates that the pairwise consistency of SC orders is
instrumental in forbidding the test.  Namely, by the consistency of SC order
with \po{} and~\coh, we have $b \SC{agent} e$ (all intermediate events are in
the same agent scope instance and bear appropriate scope annotations);
similarly we have $e \SC{wg} b$, and thus reach an inconsistency.

\pagebreak

\appendix
\section{\label{procedure}Checks and procedures}
A model text is a list of instructions.

Checks are special instructions that, depending on their outcome, will let the
execution of the model continue or on the contrary stop it.

For instance we can test that the two relations \coh{} and \po{} are consistent
with the instruction:
\begin{verbatim}
irreflexive coh;po as CohPoCons
\end{verbatim}

Here, execution will continue when \coh{} and~\po{} are consistent, \emph{i.e.}
when the sequence relation $\coh; \po$ is irreflexive.  Note that checks have
an optional name, introduced by the \texttt{as} keyword, e.g. for documentation
purposes.

In the case of the consistency check it may be interesting to abstract the
details of the check by defining a procedure:
\begin{verbatim}
procedure consistent(a,b) =
  irreflexive a;b
end
\end{verbatim}

A procedure is called by using the explicit ``\texttt{call}'' keyword.
As an example the consistency of \coh{} and~\po{} can be checked as follows:
\begin{verbatim}
call consistent(coh,po) as CohPoCons
\end{verbatim}

Procedures can of course call other procedures.
For instance we define equality by double inclusion as follows:
\begin{verbatim}
(* Relation a includes relation b, ie b(x,y) => a(x,y) *)
procedure includes(a,b) = empty b \ a end
procedure equals(a,b) =
  call includes(a,b)
  call includes(b,a)
end
\end{verbatim}
Notice how the set difference operator ``\verb+\+'' is used
to express inclusion : we have $b \subseteq a$, iff
$b \setminus a$ is empty.

\section{\label{coh}Generating \coh}

The ``coherence'' relation can be generated by \prog{herd} from the $\coinit$
pre-defined relation. The relation $\coinit$ expresses some constraints on the
writes: it relates initial writes to all other writes and all non-final writes
to final writes, for each location~$L$.

%These constraints on writes are introduced by \prog{herd} initial machinery
%that enumerates all candidate executions, considering all possible
%final writes\footnote{As a matter of fact, we assume that each location
%holds a well defined value at the end of program execution, and we
%enumerate all such final values.} in turn.

In \prog{herd}, we can generate all orders on a certain set of events with the
\texttt{linearisations($S$,$R$)} primitive that takes two arguments: a set of
events~$S$ and a relation~$R$.  The primitive builds $R_S$, the restriction
of~$R$ to $S$ (written \texttt{$R$ \& ($S$ * $S$)} in the \cat{} language).  If
$R_S$ is acyclic, the call to {\tt linearisations} will return the set of all
total orders that extend $R_S$. Otherwise, \emph{i.e.} if $R_S$ has a cycle,
the primitive returns the empty set. 
%\fixme{jade@Luc: il nous faut des crobards ici}

Hence, assuming $S_L$ to be the set of all memory events to location~$L$,
one can generate the set of all possible $\cohl{L}$ by the call
\texttt{linearisations($S_L$,co0)}:
\begin{verbatim}
let makeCohL(s) = linearisations(s,co0)
\end{verbatim}

In fact, we want to generate the set of all possible $\coh$ relations,
\emph{i.e.} all the unions of all the possible $\cohl{L}$ orders for all
locations~$L$. To that end we use another \cat{} primitive:
\texttt{partition($S$)}, which takes a set of events as argument and
returns a set of set of events $T = \{S_1,\ldots,S_n\}$, where each
$S_i$ is the set of all events in $S$ that act on location $L_i$,
and, of course $S$ is the union $\bigcup_{i=1}^{i=n} S_i$.
%\fixme{jade@Luc: il nous faut des crobards ici}

To combining the effect of the \texttt{partition} and \texttt{linearisations}
primitives, we first define a \texttt{map} function that, given a set~$S=
\{e_1,\ldots,e_n\}$ and a function $f$, returns the set
$\{f(e_1),\ldots,f(e_n)\}$:
\begin{verbatim}
let map f  =
  let rec do_map es = match es with
  || {} -> {}
  || e ++ es -> f e ++ do_map es
  end in
  do_map
\end{verbatim}
%Notice that \texttt{map} is written in curried style.
\vspace*{-2mm}
\includegraphics[width=10cm]{map}

The code above uses some new \cat{} constructs: ``\texttt{++}'' is set addition
(in infix notation), ``\verb+{}+ is the empty set.

It also uses set pattern matching that permits recursion over sets,
by considering the empty and non-empty cases, in a manner similar
to list pattern matching.

Then, we generate the set of all possible \cohl{L} for all locations~$L$ as
follows:
\begin{verbatim}
let allCohL = map makeCohL (partitions(M))
\end{verbatim}
%\fixme{jade@Luc: il nous faut des crobards ici}

Now, \texttt{allCohL} is a set of set of relations, each element being the
set of all possible $\cohl{L}$ orders for a specific~$L$.  

We still need to generate all possible unions of the $\cohl{L}$ for
% all possible choices of those\fixme{jade@Luc: c'est qui those ici?} and 
all possible locations~$L$.  It can be done by another \cat{} function:
\texttt{cross}, which takes a set of sets $S = \{S_1, S_2, \ldots, S_n\}$ as
argument and returns all possible unions built by picking elements from each of
the $S_i$: 
%\fixme{jade@Luc: il nous faut des crobards ici}

$$
\left\{\, e_1 \cup e_2 \cup \cdots \cup e_n \mid
e_1 \in S_1, e_2 \in S_2, \ldots, e_n \in S_n \,\right\}
$$

We first define a classical \texttt{fold} function over sets:
given a set $S = \{ e_1, e_2, \ldots, e_n\}$, an initial value~$y_0$
and an associative function $f$~that takes a pair $(e,y)$ as argument,
\texttt{fold} computes:
$$
f (e_{i_1},f (e_{i_2}, \ldots, f(e_{i_n},y_0)))  
$$
where $i_1, i_2, \ldots, i_n$ defines a permutation
of the indices $1, 2, \ldots, n$.

\begin{verbatim}
let fold f =
  let rec fold_rec (es,y) = match es with
  || {} -> y
  || e ++ es -> fold_rec (es,f (e,y))
  end in
  fold_rec
\end{verbatim}
As an example, consider:
\begin{verbatim}
let flatten S = fold (fun (e,y) -> e | y) (S,{})
\end{verbatim}
The function~\verb+flatten+
takes a set of sets as argument and returns their union.
As another example, we could have defined \texttt{map} as follows:
\begin{verbatim}
let map f = fun S -> fold (fun (e,y) -> f S ++ y) (S,{})
\end{verbatim}

We now write \texttt{cross}:
\begin{verbatim}
let rec cross ess = match ess with
  || {} -> { 0 }
  || es ++ ess ->
      let yss = cross ess in
      fold
        (fun (e,r) -> map (fun ys -> e | ys) yss | r)
        (es,{})           
  end      
\end{verbatim}
Notice, in the code above, that we use the union operator ``\verb+|+'' and of
the empty relation ``\verb+0+''. 

Finally we generate all possible $\coh$ ``orders'' by:
\begin{verbatim}
let allCoh = cross allCohL
\end{verbatim}

\section{Bell file \label{bell}}

\begin{verbatim}
"HSA bell"

enum kind = 'ordinary || 'atomic

enum size = 'single || 'double
let same-size = (Single*Single) | (Double*Double)

enum memory-order = 'rlx
                  || 'scacq
                  || 'screl
                  || 'scar

enum scopes =
   'wi
|| 'wave
|| 'wg
|| 'agent
|| 'system

let narrower(s) = match s with
  || 'system -> 'agent
  || 'agent -> 'wg
  || 'wg -> 'wave
  || 'wave -> 'wi
end

let wider(s) = match s with
  || 'agent -> 'system
  || 'wg -> 'agent
  || 'wave -> 'wg
  || 'wi -> 'wave
end

default R[{'ordinary},{'rlx},{'wi},single]
events R[{'ordinary},{'rlx},{'wi},size]
events R[{'atomic},{'rlx,'scacq,'scar},scopes,size]
default W[{'ordinary},{'rlx},{'wi},single]
events W[{'ordinary},{'rlx},{'wi},size]
events W[{'atomic},{'rlx,'screl,'scar},scopes,size]
events RMW[{'atomic},memory-order,scopes,size]
default F['scar,'system]
events F[{'scacq,'screl,'scar},scopes]

enum memory-segments = 'global
                    || 'group
                    || 'private
                    || 'kernarg
                    || 'readonly

enum regions = 'group || 'global
events regions[regions]

let rec all-events(tag) = match tag with
|| 'system -> tag2events(tag)
|| _ -> tag2events(tag) | all-events(wider(tag))
end

let do-same-instance(tag) =
 let evts = all-events(tag) in
 tag2scope(tag) & (evts * evts)

let same-system = do-same-instance('system)
let same-agent = do-same-instance('agent)
let same-wg = do-same-instance('wg)
let same-wave = do-same-instance('wave)
let same-wi = do-same-instance('wi)

let same-instance(s) = match s with
|| 'system -> same-system
|| 'agent -> same-agent
|| 'wg -> same-wg
|| 'wave -> same-wave
|| 'wi -> same-wi
end

let union-scopes f =
  let rec u_rec sis = match sis with
  || {} -> 0
  || si ++ sis -> f si | u_rec sis
  end in
  u_rec scopes

let Match =  union-scopes same-instance

let Release = Screl | Scar
let Acquire = Scacq | Scar
let Synchronizing = Acquire | Release
let Special = Atomic | F
\end{verbatim}

\pagebreak

\section{Cat file}

\verbatiminput{doc.cat}

%\fixme{jade: a faire, avec les SC orders emballes dans une procedure}

\pagebreak

\section{Tests from the documentation}
\subsection{Synchronizing operations are sequentially consistent by definition}
\begin{multicols}{2}
\verbatiminput{img/HSA01.litmus}
\end{multicols}
\begin{figure}[htp]
\caption{\label{hsa01} Test~\ltst{HSA01} is forbidden by the consistency
of \SC{wg} and \coh{}.}
\begin{center}\moveback\fmt{HSA01}\end{center}
\end{figure}

\pagebreak

\subsection{Successful synchronization between units of execution}
\verbatiminput{img/HSA02.litmus}

\begin{figure}[htp]
\caption{\label{hsa02} Test~\ltst{HSA02} is forbidden by the consistency
of \hhb{} and \coh{}.}
\begin{center}\moveback\fmt{HSA02}\end{center}
\end{figure}

\pagebreak

\subsection{Correct synchronization, safe transitivity with a single scope}
\verbatiminput{img/HSA03.litmus}

\begin{figure}[H]
\caption{\label{hsa03} Test~\ltst{HSA03} is forbidden by the consistency
of \hhb{} and \coh{}.}
\begin{center}\moveback\fmt{HSA03}\end{center}
\end{figure}

\pagebreak

\subsection{\label{ex04}Race-free transitive synchronization through multiple scopes}
\verbatiminput{img/HSA04.litmus}
{\color{blue}
In the HSA document, all variables, including
the variable~\texttt{z},
are defined in the group segment. However
the variable~\texttt{z} is used ti
synchronize \myth{1} and~\myth{2}, which are not in the same work-group.
This looks like a minor error.
\noindent\textbf{NB:} As segments are not implemented yet
in \herd{}, we assume global segment for all variables.}

\begin{figure}[htp]
\caption{\label{hsa04} Test~\ltst{HSA04} is forbidden by the consistency
of \hhb{} and \coh{}.}
\begin{center}\moveback\fmt{HSA04}\end{center}
\end{figure}

\pagebreak

\subsection{Successful synchronization through scope inclusion}
\verbatiminput{img/HSA05.litmus}

\begin{figure}[htp]
\caption{\label{hsa05} Test~\ltst{HSA05} is forbidden by the consistency
of \hhb{} and \coh{}.}
\begin{center}\moveback\fmt{HSA05}\end{center}
\end{figure}

\pagebreak

\subsection{Successful synchronization through scope inclusion and scope transitivity}
\verbatiminput{img/HSA06.litmus}
This example is quite similar to~\ltst{HSA04} (see Section~\ref{ex04}).
There are two differences:
\begin{itemize}
\item All variables of test~\ltst{HSA06} are in the global segments,
while they are in the group segment in example~\ltst{HSA04}
\item The
scope annotations of the read acquire operation on variable~\texttt{y} by
unit~\myth{1} (event~$c$ in figures~\ref{hsa04} and~\ref{hsa06}) differ:
 it is agent for~\ltst{HSA06} and work-group for~\ltst{HSA04}.
{\color{blue} In that sense, this test~\ltst{HSA06} looks like
a combination of teh two previous tests~\ltst{HSA04} and~\ltst{HSA05}.}
\end{itemize}

\begin{figure}[htp]
\caption{\label{hsa06} Test~\ltst{HSA06} is forbidden by the consistency
of \hhb{} and \coh{}.}
\begin{center}\moveback\fmt{HSA06}\end{center}
\end{figure}


\pagebreak


\subsection{Coh and hhb must be consistent}

\verbatiminput{img/HSA07.litmus}
As expected the test~\ltst{HSA07} is forbidden
by the consistency of \hhb{} and~\coh -- See Figure~\ref{hsa07}.
{\color{blue} One may observe that all the previous
tests, except~\ltst{HSA01}, illustrate the consistency
of \hhb{} and~\coh{}.}

\begin{figure}[htp]
\caption{Test~\ltst{HSA07} is forbidden by\ldots}
\begin{center}
\subfloat[\label{hsa07} \ldots{} the consistency of \hhb{} and~\coh{}.]{\rule{2cm}{0cm}\fmt{HSA07}\rule{2cm}{0cm}}

\vspace*{2cm}

\subfloat[\label{hsa07bis} \ldots or by value of a load.]{\fmt{HSA07+BIS}}
\end{center}
\end{figure}


One may remark that forbidding this test also results
from the value-of-a-load rule. Figure~\ref{hsa07bis} illustrate this point:
here the relations~\hhb{} and~\coh{} are consistent.
Yet the arrow $a \rf e$ violates value-of-a-load,
as the read~$e$ does not get its value from the most recent write in~\coh{}.

\pagebreak

\subsection{Separate segment synchronization}
{\color{blue} From our perspective there is a problem with
this example. The HSA document comments ``The example shows that
synchronisation can cross segments. Even though the atomic stores
and loads specify a location in global memory, they still synchronise
teh group location~Y''. However the atomic stores
and loads specify specify location~Y, which belong to the group segment.
Moreover, we still do not quite understand how memory segments fit in the
memory model. See our remarks in Section~\ref{segment}.}



\pagebreak

\subsection{Successful synchronization between units of execution using relaxed atomics}
\verbatiminput{img/HSA09.litmus}

This test illustrates successful synchronization by the means of fences,
see Figure~\ref{hsa09}.
{\color{blue}
It should perhaps be noticed that fences here suffices to restore~SC.
This would not be the case for test~\ltst{HSA12} (Section~\ref{ex12}).}

\begin{figure}[htp]
\caption{\label{hsa09} Test~\ltst{HSA09} is forbidden by the consistency
of \hhb{} and \coh{}.}
\begin{center}\moveback\fmt{HSA09}\end{center}
\end{figure}


\pagebreak

\subsection{Store speculation is not observable}
\verbatiminput{img/HSA10.litmus}

\begin{figure}[htp]
\caption{\label{hsa10} Test~\ltst{HSA10} is forbidden by the irreflexivity
of~$\gdo{} = (\ldo \cup \rfe)^{+}$.}
\begin{center}\moveback\fmt{HSA10}\end{center}
\end{figure}


\pagebreak

\subsection{No out-of-thin-air values}

\verbatiminput{img/HSA11.litmus}
This is the paradigmatic ``no values out-of-thin-air'' test.
As illustrated by Figure~\ref{hsa11}, our models reject this
tests by the irreflexivity check of~\gdo{}.
Observe that the value of events is a variable ``\textsf{S4}''.
This variable stands for just any integer value.


\begin{figure}[htp]
\caption{\label{hsa11} Test~\ltst{HSA11} is forbidden by the irreflexivity
of~$\gdo{} = (\ldo \cup \rfe)^{+}$.}
\begin{center}\moveback\fmt{HSA11}\end{center}
\end{figure}

\pagebreak

\subsection{\label{ex12}Dekker's Algorithm}

\verbatiminput{img/HSA12.litmus}

\begin{figure}[htp]
\caption{\label{hsa12} Test~\ltst{HSA12} is allowed.}
\begin{center}\moveback\fmt{HSA12}\end{center}
\end{figure}

\begin{figure}[htp]
\caption{\label{hsa12fences} Test~\ltst{HSA12+fences} is allowed.}
\begin{center}\moveback\fmt{HSA12+fences}\end{center}
\end{figure}

\pagebreak

\subsection{Conflict without synchronization}
\verbatiminput{img/HSA13.litmus}
This test illustrates an ordinary race.
There is no \hhb-induced order between events $a$ and~$b$, which
are to the same location, by different units, one event ($a$) being a write,
see~Figure~\ref{hsa13}.
\begin{figure}[htp]
\caption{\label{hsa13} Test~\ltst{HSA13} is racy.}
\begin{center}\moveback\fmt{HSA13}\end{center}
\end{figure}

\pagebreak

\subsection{Insufficient scope}
\verbatiminput{img/HSA14.litmus}
This test illustrates a special race by non-matching scopes.
Figure~\ref{hsa14} depict two races: one is between atomic events~$b$ and~$c$
and stems from $b$ and~$c$ belonging to different work-groups, while bearing
the \texttt{wg} scope annotation.
More precisely, Figure~\ref{hsa14bis}
depicts the relations~\same{wg} and~\symr{matches}, which do \emph{not} relate $b$ and~$c$.
And indeed,
(see Section~\ref{specialconflict}) pairs related by \symr{matches}
are subtracted from potential special races.

Moreover, as a result of $b$ and~$c$ being in different work-groups,
there events $a$ and~$d$ are not ordered by \hhb (which reduces to~\po),
and we have a second (ordinary) race.
\begin{figure}[htp]
\caption{Test~\ltst{HSA14}}
\begin{center}
\subfloat[\label{hsa14} Test~\ltst{HSA14} is racy.]{\rule{2cm}{0cm}\fmt{HSA14}\rule{2cm}{0cm}}

\vspace*{1cm}

\subfloat[\label{hsa14bis} Scopes for test~\ltst{HSA14}.]{\fmt{HSA14+SCOPE}}
\end{center}
\end{figure}

\end{document}


