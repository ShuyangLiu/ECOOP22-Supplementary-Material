> et enfin, HSA est pret a etre prouve tu penses?

Pas tout à fait, je viens de trouver un exemple qui invalide l'équivalence.
C'est un SB quatre fois en chaine sur le scope tree
 (system (agent (wg 0 1) (wg 2)) (agent 3))

0 et 1 communiquent au niveau wg
1 et 2 au niveau agent
et 2 ->3 -> 0 au niveau system.


Je viens de le commettre

Pour voir dans catalogue/hsa

sh ALL.sh -model doc/doc-bis-co.cat tests/extra/t4.litmus
--> interdit
sh ALL.sh -model doc/doc-bis-co-opt.cat tests/extra/t4.litmus
--> autorisé

Pour voir le problème,
sh ALL.sh -model doc/doc-bis-co-opt.cat tests/extra/t4.litmus -show prop -gv

On voit un cycle des trois pré-ordres SWG,SAGENT et SSYSTEM
qui n'est pas rejeté car les ordres ne sont vérifiés compatibles
(acyclic de l'union) deux à deux.

sh ALL.sh -model doc/doc-bis-co.cat tests/extra/t4.litmus -show prop -gv -skipchecks ScSc

Te montre les quatre exécutions rejetée par les tests de consistence deux
à deux. Les deux premières sont par la consistence de SAGENT et SSYSTEM,
les deux dernière par la consitence de SAGENT et SWG.

Je vois deux patchs.

1. Passer au test d'acyclicité de l'union des préordres SC, mais c'est un
peu à l'arrache.

2. Les préordres (hhb|coh) & same_instance(lvl)
   pourraient prendre en compte les préordres de niveau inférieur.
   Par ex sur le premier dessin des ordres totaux (total.pdf attaché)
   Les threads 0 et 1 sont dans le même workgroup, l'evt d'entrée (a)
   est dans la même scope instance que l'evt de sortie (d). Or ces deux evts
   agissent au niveau agent tous les deux.  Il faut donc dans la version
   ordre total les ordonner. Le préordre n'en tient pas compte
   (ie pas de relation entre (a) et (d) voir l'image "partial.pdf".
   Pour ce faire je propose d'inclure la fermeture transitive du préordre
   précédent dans le préordre courant ie par ex

   let SAGENT = SWG+ | hhb | po & sync-instance('agent)

   On sera ainsi plus fort que la simple acyclicité de SWG et SAGENT,
   car SAGENT sera plus grande.
